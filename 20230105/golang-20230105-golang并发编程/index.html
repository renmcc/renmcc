<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>golang并发编程 | ren_mccの博客</title><meta name="author" content="ren_mcc"><meta name="copyright" content="ren_mcc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="并发模型   任何语言的并行，到操作系统层面，都是内核线程的并行。同一个进程内的多个线程共享系统资源，进程的创建、销毁、切换比线程大很多。从进程到线程再到协程, 其实是一个不断共享, 不断减少切换成本的过程。        协程 线程     创建数量 轻松创建上百万个协程而不会导致系统资源衰竭 通常最多不能超过1万个   内存占用 初始分配4k堆栈，随着程序的执行自动增长删除 创建线程时必须指定">
<meta property="og:type" content="article">
<meta property="og:title" content="golang并发编程">
<meta property="og:url" content="https://renm.cc/20230105/golang-20230105-golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="ren_mccの博客">
<meta property="og:description" content="并发模型   任何语言的并行，到操作系统层面，都是内核线程的并行。同一个进程内的多个线程共享系统资源，进程的创建、销毁、切换比线程大很多。从进程到线程再到协程, 其实是一个不断共享, 不断减少切换成本的过程。        协程 线程     创建数量 轻松创建上百万个协程而不会导致系统资源衰竭 通常最多不能超过1万个   内存占用 初始分配4k堆栈，随着程序的执行自动增长删除 创建线程时必须指定">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://renm.cc/img/yuanshen/avatar/8f16e2511e864f01955f9659b351ee21!400x400.jpeg">
<meta property="article:published_time" content="2023-01-05T07:18:21.000Z">
<meta property="article:modified_time" content="2023-06-28T13:47:21.762Z">
<meta property="article:author" content="ren_mcc">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://renm.cc/img/yuanshen/avatar/8f16e2511e864f01955f9659b351ee21!400x400.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://renm.cc/20230105/golang-20230105-golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'golang并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><script src="/js/jquery.min.js"></script><link rel="stylesheet" href="/js/function.min.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="/js/custom.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg" style="background-image: url(/img/backgroud7.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar2.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">148</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/yuanshen/avatar/8f16e2511e864f01955f9659b351ee21!400x400.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ren_mccの博客</span></a><a class="nav-page-title" href="/"><span class="site-name">golang并发编程</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">golang并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-05T07:18:21.000Z" title="发表于 2023-01-05 15:18:21">2023-01-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-28T13:47:21.762Z" title="更新于 2023-06-28 21:47:21">2023-06-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/golang/">golang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2023-06-28 21:47:21&quot;}" hidden></div><h2 id="并发模型">并发模型</h2>
<p>  任何语言的并行，到操作系统层面，都是内核线程的并行。同一个进程内的多个线程共享系统资源，进程的创建、销毁、切换比线程大很多。从进程到线程再到协程, 其实是一个不断共享, 不断减少切换成本的过程。<br>
<img src="./1v1.png" width="410" /><br>
<img src="./1v1t.png" width="310" /><br>
<img src="./mvn.png" width="230" /></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left">协程</th>
<th style="text-align:left">线程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建数量</td>
<td style="text-align:left">轻松创建上百万个协程而不会导致系统资源衰竭</td>
<td style="text-align:left">通常最多不能超过1万个</td>
</tr>
<tr>
<td style="text-align:center">内存占用</td>
<td style="text-align:left">初始分配4k堆栈，随着程序的执行自动增长删除</td>
<td style="text-align:left">创建线程时必须指定堆栈且是固定的，通常以M为单位</td>
</tr>
<tr>
<td style="text-align:center">切换成本</td>
<td style="text-align:left">协程切换只需保存三个寄存器，耗时约200纳秒</td>
<td style="text-align:left">线程切换需要保存几十个寄存器，耗时约1000纳秒</td>
</tr>
<tr>
<td style="text-align:center">调度方式</td>
<td style="text-align:left">非抢占式，由Go runtime主动交出控制权（对于开发者而言是抢占式）</td>
<td style="text-align:left">在时间片用完后，由 CPU 中断任务强行将其调度走，这时必须保存很多信息</td>
</tr>
<tr>
<td style="text-align:center">创建销毁</td>
<td style="text-align:left">goroutine因为是由Go runtime负责管理的，创建和销毁的消耗非常小，是用户级的</td>
<td style="text-align:left">创建和销毁开销巨大，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池</td>
</tr>
</tbody>
</table>
<p>查看逻辑核心数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(runtime.NumCPU())</span><br></pre></td></tr></table></figure>
<p>Go语言的MPG并发模型<br>
<img src="./mpg.png" width="150" /><br>
  M(Machine)对应一个内核线程。P(Processor)虚拟处理器，代表M所需的上下文环境，是处理用户级代码逻辑的处理器。P的数量由环境变量中的GOMAXPROCS决定，默认情况下就是核数。G(Goroutine)本质上是轻量级的线程，G0正在执行，其他G在等待。M和内核线程的对应关系是确定的。G0阻塞(如系统调用)时，P与G0、M0解绑，P被挂到其他M上，然后继续执行G队列。G0解除阻塞后，如果有空闲的P，就绑定M0并执行G0；否则G0进入全局可运行队列(runqueue)。P会周期性扫描全局runqueue，使上面的G得到执行；如果全局runqueue为空，就从其他P的等待队列里偷一半G过来。<br>
<img src="./mpg_detail.png" width="800" /></p>
<h2 id="Goroutine的使用">Goroutine的使用</h2>
<p>  启动协程的两种常见方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Add&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> Add(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;add&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>  优雅地等子协程结束:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">10</span>) <span class="comment">//加10</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123; <span class="comment">//开N个子协程</span></span><br><span class="line">		<span class="keyword">defer</span> wg.Done() <span class="comment">//减1</span></span><br><span class="line">		<span class="comment">//do something</span></span><br><span class="line">	&#125;(i, i+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() <span class="comment">//等待减为0</span></span><br></pre></td></tr></table></figure>
<p>  父协程结束后，子协程并不会结束。main协程结束后，所有协程都会结束。<br>
向协程内传递变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d\t&quot;</span>, v) <span class="comment">//用的是协程外面的全局变量v。输出4 4 4 4</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d\t&quot;</span>, value) <span class="comment">//输出1 4 2 3</span></span><br><span class="line">		&#125;(v) <span class="comment">//把v的副本传到协程内部</span></span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  有时候需要确保在高并发的场景下有些事情只执行一次，比如加载配置文件、关闭管道等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resource <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> loadResourceOnce sync.Once <span class="function"><span class="keyword">func</span> <span class="title">LoadResource</span><span class="params">()</span></span> &#123;</span><br><span class="line">	loadResourceOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		resource[<span class="string">&quot;1&quot;</span>] = <span class="string">&quot;A&quot;</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单例模式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> singleton *Singleton</span><br><span class="line"><span class="keyword">var</span> singletonOnce sync.Once</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSingletonInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">	singletonOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		singleton = &amp;Singleton&#123;&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> singleton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  何时会发生panic:</p>
<ul>
<li>运行时错误会导致panic，比如数组越界、除0。</li>
<li>程序主动调用panic(error)。</li>
</ul>
<p>  panic会执行什么：</p>
<ol>
<li>逆序执行当前goroutine的defer链（recover从这里介入）。</li>
<li>打印错误信息和调用堆栈。</li>
<li>调用exit(2)结束整个进程。</li>
</ol>
<p>关于defer</p>
<ul>
<li>defer在函数退出前被调用，注意不是在代码的return语句之前执行，因为return语句不是原子操作。</li>
<li>如果发生panic，则之后注册的defer不会执行。</li>
<li>defer服从先进后出原则，即一个函数里如果注册了多个defer，则按注册的逆序执行。</li>
<li>defer后面可以跟一个匿名函数。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goo</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;x=%d\n&quot;</span>, x)</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a, b <span class="type">int</span>, p <span class="type">bool</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	c := a*<span class="number">3</span> + <span class="number">9</span></span><br><span class="line">	<span class="comment">//defer是先进后出，即逆序执行</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;first defer&quot;</span>)</span><br><span class="line">	d := c + <span class="number">5</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;second defer&quot;</span>)</span><br><span class="line">	e := d / b <span class="comment">//如果发生panic，则后面的defer不会执行</span></span><br><span class="line">	<span class="keyword">if</span> p &#123;</span><br><span class="line">		<span class="built_in">panic</span>(errors.New(<span class="string">&quot;my error&quot;</span>)) <span class="comment">//主动panic</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;third defer&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> goo(e) <span class="comment">//defer是在函数临退出前执行，不是在代码的return语句之前执行，因为return语句不是原子操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  recover会阻断panic的执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">soo</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">//recover必须在defer中才能生效</span></span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;			</span><br><span class="line">            fmt.Printf(<span class="string">&quot;soo函数中发生了panic:%s\n&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(errors.New(<span class="string">&quot;my error&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Channel的同步与异步">Channel的同步与异步</h2>
<p>  很多语言通过共享内存来实现线程间的通信，通过加锁来访问共享数据，如数组、map或结构体。go语言也实现了这种并发模型。<br>
<img src="./share_mem.png" width="500" /></p>
<p>  CSP(communicating sequential processes)讲究的是“以通信的方式来共享内存”，在go语言里channel是这种模式的具体实现。<br>
<img src="./csp.png" width="600" /></p>
<p>异步管道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asynChann := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>  channel底层维护一个环形队列（先进先出），make初始化时指定队列的长度。队列满时，写阻塞；队列空时，读阻塞。sendx指向下一次写入的位置， recvx指向下一次读取的位置。 recvq维护因读管道而被阻塞的协程，sendq维护因写管道而被阻塞的协程。<br>
<img src="./queue.png" width="400" /></p>
<p>  同步管道可以认为队列容量为0，当读协程和写协程同时就绪时它们才会彼此帮对方解除阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syncChann := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>  channel仅作为协程间同步的工具，不需要传递具体的数据，管道类型可以用struct{}。空结构体变量的内存占用为0，因此struct{}类型的管道比bool类型的管道还要省内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">sc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>关于channel的死锁与阻塞</p>
<ol>
<li>Channel满了，就阻塞写；Channel空了，就阻塞读。</li>
<li>阻塞之后会交出cpu，去执行其他协程，希望其他协程能帮自己解除阻塞。</li>
<li>如果阻塞发生在main协程里，并且没有其他子协程可以执行，那就可以确定“希望永远等不来”，自已把自己杀掉，报一个fatal error:deadlock出来。</li>
<li>如果阻塞发生在子协程里，就不会发生死锁，因为至少main协程是一个值得等待的“希望”，会一直等（阻塞）下去。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">//有1个缓冲可以用，无需阻塞，可以立即执行</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;      <span class="comment">//子协程1</span></span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">//sleep一个很长的时间</span></span><br><span class="line">		&lt;-ch                        <span class="comment">//如果把本行代码注释掉，main协程5秒钟后会报fatal error</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;sub routine 1 over&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">//由于子协程1已经启动，寄希望于子协程1帮自己解除阻塞，所以会一直等子协程1执行结束。如果子协程1执行结束后没帮自己解除阻塞，则希望完全破灭，报出deadlock</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;send to channel in main routine&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//子协程2</span></span><br><span class="line">		time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">//channel已满，子协程2会一直阻塞在这一行</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;sub routine 2 over&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;main routine exit&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭channel</p>
<ul>
<li>只有当管道关闭时，才能通过range遍历管道里的数据，否则会发生fatal error。</li>
<li>管道关闭后读操作会立即返回，如果缓冲已空会返回“0值”。</li>
<li>ele, ok := &lt;-ch  	ok==true代表ele是管道里的真实数据。</li>
<li>向已关闭的管道里send数据会发生panic。</li>
<li>不能重复关闭管道，不能关闭值为nil的管道，否则都会panic。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cloch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> cloch2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverseChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> ele := <span class="keyword">range</span> cloch &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;receive %d\n&quot;</span>, ele)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverseChannel2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ele, ok := &lt;-cloch2; ok &#123; <span class="comment">//ok==true代表管道还没有close</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;receive %d\n&quot;</span>, ele)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//管道关闭后，读操作会立即返回“0值”</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;channel have been closed, receive %d\n&quot;</span>, ele)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cloch &lt;- <span class="number">1</span></span><br><span class="line">	<span class="built_in">close</span>(cloch)</span><br><span class="line">	traverseChannel() <span class="comment">//如果不close就直接通过range遍历管道，会发生fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;==================&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> traverseChannel2()</span><br><span class="line">	cloch2 &lt;- <span class="number">1</span></span><br><span class="line">	<span class="built_in">close</span>(cloch2)</span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  channel在并发编程中有多种玩法，经常用channel来实现协程间的同步。<br>
<img src="./sync.png" width="500" /></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upstream</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">15</span> * time.Millisecond)</span><br><span class="line">	fmt.Println(<span class="string">&quot;一个上游协程执行结束&quot;</span>)</span><br><span class="line">	ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downstream</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	&lt;-ch</span><br><span class="line">	fmt.Println(<span class="string">&quot;下游协程开始执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	upstreamNum := <span class="number">4</span>   <span class="comment">//上游协程的数量</span></span><br><span class="line">	downstreamNum := <span class="number">5</span> <span class="comment">//下游协程的数量</span></span><br><span class="line"></span><br><span class="line">	upstreamCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, upstreamNum)</span><br><span class="line">	downstreamCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, downstreamNum)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//启动上游协程和下游协程，实际下游协程会先阻塞</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; upstreamNum; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> upstream(upstreamCh)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; downstreamNum; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> downstream(downstreamCh)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//同步点</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; upstreamNum; i++ &#123;</span><br><span class="line">		&lt;-upstreamCh</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过管道让下游协程开始执行</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; downstreamNum; i++ &#123;</span><br><span class="line">		downstreamCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="comment">//等下游协程执行结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发安全性">并发安全性</h2>
<p>  多协程并发修改同一块内存，产生资源竞争。go run或go build时添加-race参数检查资源竞争情况。<br>
  n++不是原子操作，并发执行时会存在脏写。n++分为3步：取出n，加1，结果赋给n。测试时需要开1000个并发协程才能观察到脏写。</p>
<img src="./n++.png" width="500" />
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomic</span>.<span class="title">AddInt32</span><span class="params">(addr *<span class="type">int32</span>, delta <span class="type">int32</span>)</span></span> (<span class="built_in">new</span> <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomic</span>.<span class="title">LoadInt32</span><span class="params">(addr *<span class="type">int32</span>)</span></span> (val <span class="type">int32</span>)</span><br></pre></td></tr></table></figure>
<p>  把n++封装成原子操作，解除资源竞争，避免脏写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock sync.RWMutex		<span class="comment">//声明读写锁，无需初始化</span></span><br><span class="line">lock.Lock() lock.Unlock()	<span class="comment">//加写锁和释放写锁</span></span><br><span class="line">lock.RLock() lock.RUnlock()	<span class="comment">//加读锁和释放读锁</span></span><br></pre></td></tr></table></figure>
<p>  任意时刻只可以加一把写锁，且不能加读锁。没加写锁时，可以同时加多把读锁，读锁加上之后不能再加写锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> lock sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inc1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n++ <span class="comment">//n++不是原子操作，它分为3步：取出n，加1，结果赋给n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inc2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	atomic.AddInt32(&amp;n, <span class="number">1</span>) <span class="comment">//封装成原子操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inc3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lock.Lock()   <span class="comment">//加写锁</span></span><br><span class="line">	n++           <span class="comment">//任一时刻，只有一个协程能进入临界区域</span></span><br><span class="line">	lock.Unlock() <span class="comment">//释放写锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> P = <span class="number">1000</span> <span class="comment">//开大量协程才能把脏写问题测出来</span></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(P)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; P; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			inc1()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;finally n=%d\n&quot;</span>, n) <span class="comment">//多运行几次，n经常不等于1000</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;===========================&quot;</span>)</span><br><span class="line">	n = <span class="number">0</span> <span class="comment">//重置n</span></span><br><span class="line">	wg = sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(P)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; P; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			inc2()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;finally n=%d\n&quot;</span>, atomic.LoadInt32(&amp;n))</span><br><span class="line">	fmt.Println(<span class="string">&quot;===========================&quot;</span>)</span><br><span class="line">	n = <span class="number">0</span> <span class="comment">//重置n</span></span><br><span class="line">	wg = sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(P)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; P; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			inc3()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	lock.RLock() <span class="comment">//加读锁。当写锁被其他协程持有时，加读锁操作将被阻塞；否则，如果其他协程持有读锁，加读锁操作不会被阻塞</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;finally n=%d\n&quot;</span>, n)</span><br><span class="line">	lock.RUnlock() <span class="comment">//释放读锁</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;===========================&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  数组、slice、struct允许并发修改（可能会脏写），并发修改map有时会发生panic。如果需要并发修改map请使用sync.Map。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//写偶数位</span></span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i += <span class="number">2</span> &#123;</span><br><span class="line">			arr[i] = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//写奇数位</span></span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(arr); i += <span class="number">2</span> &#123;</span><br><span class="line">			arr[i] = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(arr) <span class="comment">//输出[0 1 0 1 0 1 0 1 0 1]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;=======================&quot;</span>)</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">var</span> stu Student</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		stu.Name = <span class="string">&quot;Fred&quot;</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		stu.Age = <span class="number">20</span></span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s %d\n&quot;</span>, stu.Name, stu.Age)</span><br><span class="line">	fmt.Println(<span class="string">&quot;=======================&quot;</span>)</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		m.Store(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		m.Store(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v2&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(m.Load(<span class="string">&quot;k1&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多路复用">多路复用</h2>
<p>  操作系统级的I/O模型有：</p>
<ul>
<li>阻塞I/O</li>
<li>非阻塞I/O</li>
<li>信号驱动I/O</li>
<li>异步I/O</li>
<li>多路复用I/O<br>
  Linux下，一切皆文件。包括普通文件、目录文件、字符设备文件（键盘、鼠标）、块设备文件（硬盘、光驱）、套接字socket等等。文件描述符（File descriptor，FD）是访问文件资源的抽象句柄，读写文件都要通过它。文件描述符就是个非负整数，每个进程默认都会打开3个文件描述符：0标准输入、1标准输出、2标准错误。由于内存限制，文件描述符是有上限的，可通过ulimit –n查看，文件描述符用完后应及时关闭。</li>
</ul>
<p>阻塞I/O</p>
<img src=./block.png width=570 />  
<p>非阻塞I/O</p>
<img src=./non_block.png width=600 /> 
<p>  read和write默认是阻塞模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; </span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br></pre></td></tr></table></figure>
<p>  通过系统调用fcntl可将文件描述符设置成非阻塞模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flags = fcntl(fd, F_GETFL, <span class="number">0</span>); </span><br><span class="line">fcntl(fd, F_SETFL, flags | O_NONBLOCK);</span><br></pre></td></tr></table></figure>
<p>多路复用I/O<br>
  select系统调用可同时监听1024个文件描述符的可读或可写状态。poll用链表存储文件描述符，摆脱了1024的上限。各操作系统实现了自己的I/O多路复用函数，如epoll、 evport 和kqueue等。</p>
<img src=./select.png width=300 /> 
<img src=./multi_reuse.png width=700 /> 
<p>  go多路复用函数以netpoll为前缀，针对不同的操作系统做了不同的封装，以达到最优的性能。在编译go语言时会根据目标平台选择特定的分支进行编译。</p>
<img src=./go_multi_reuse.png width=300 /> 
<p>  利用go channel的多路复用实现倒计时发射的demo。</p>
<img src=./bububu.png width=500 /> 
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//倒计时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countDown</span><span class="params">(countCh <span class="keyword">chan</span> <span class="type">int</span>, n <span class="type">int</span>, finishCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123; <span class="comment">//从n开始倒数</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	ticker := time.NewTicker(<span class="number">1</span> * time.Second) <span class="comment">//创建一个周期性的定时器，每隔1秒执行一次</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		countCh &lt;- n <span class="comment">//把n放入管道</span></span><br><span class="line">		&lt;-ticker.C   <span class="comment">//等1秒钟</span></span><br><span class="line">		n--          <span class="comment">//n减1</span></span><br><span class="line">		<span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;  <span class="comment">//n减到0时退出</span></span><br><span class="line">			ticker.Stop()          <span class="comment">//停止定时器</span></span><br><span class="line">			finishCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">//成功结束</span></span><br><span class="line">			<span class="keyword">break</span>                  <span class="comment">//退出for循环</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中止</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abort</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1</span>)</span><br><span class="line">	os.Stdin.Read(buffer) <span class="comment">//阻塞式IO，如果标准输入里没数据，该行一直阻塞。注意在键盘上敲完后要按下Enter才会把输入发给Stdin</span></span><br><span class="line">	ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	countCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	finishCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> countDown(countCh, <span class="number">10</span>, finishCh) <span class="comment">//开一个子协程，去往countCh和finishCh里放数据</span></span><br><span class="line">	abortCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> abort(abortCh) <span class="comment">//开一个子协程，去往abortCh里放数据</span></span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">	<span class="keyword">for</span> &#123; <span class="comment">//循环监听</span></span><br><span class="line">		<span class="keyword">select</span> &#123; <span class="comment">//同时监听3个channel，谁先准备好就执行谁，然后进入下一次for循环</span></span><br><span class="line">		<span class="keyword">case</span> n := &lt;-countCh:</span><br><span class="line">			fmt.Println(n)</span><br><span class="line">		<span class="keyword">case</span> &lt;-finishCh:</span><br><span class="line">			fmt.Println(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span> LOOP <span class="comment">//退出for循环。在使用for select时，单独一个break不能退出for循环</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-abortCh:</span><br><span class="line">			fmt.Println(<span class="string">&quot;abort&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span> LOOP <span class="comment">//退出for循环</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  函数超时控制的4种实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	WorkUseTime = <span class="number">500</span> * time.Millisecond</span><br><span class="line">	Timeout     = <span class="number">100</span> * time.Millisecond</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟一个耗时较长的任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LongTimeWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(WorkUseTime)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟一个接口处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	deadline := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	workDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//把要控制超时的函数放到一个协程里</span></span><br><span class="line">		LongTimeWork()</span><br><span class="line">		workDone &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//把要控制超时的函数放到一个协程里</span></span><br><span class="line">		time.Sleep(Timeout)</span><br><span class="line">		deadline &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123; <span class="comment">//下面的case只执行最早到来的那一个</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-workDone:</span><br><span class="line">		fmt.Println(<span class="string">&quot;LongTimeWork return&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-deadline:</span><br><span class="line">		fmt.Println(<span class="string">&quot;LongTimeWork timeout&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟一个接口处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	workDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//把要控制超时的函数放到一个协程里</span></span><br><span class="line">		LongTimeWork()</span><br><span class="line">		workDone &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123; <span class="comment">//下面的case只执行最早到来的那一个</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-workDone:</span><br><span class="line">		fmt.Println(<span class="string">&quot;LongTimeWork return&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(Timeout):</span><br><span class="line">		fmt.Println(<span class="string">&quot;LongTimeWork timeout&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟一个接口处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//通过显式sleep再调用cancle()来实现对函数的超时控制</span></span><br><span class="line">	<span class="comment">//调用cancel()将关闭ctx.Done()对应的管道</span></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	workDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//把要控制超时的函数放到一个协程里</span></span><br><span class="line">		LongTimeWork()</span><br><span class="line">		workDone &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">//100毫秒后调用cancel()，关闭ctx.Done()</span></span><br><span class="line">		time.Sleep(Timeout)</span><br><span class="line">		cancel()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123; <span class="comment">//下面的case只执行最早到来的那一个</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-workDone:</span><br><span class="line">		fmt.Println(<span class="string">&quot;LongTimeWork return&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//ctx.Done()是一个管道，调用了cancel()都会关闭这个管道，然后读操作就会立即返回</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;LongTimeWork timeout&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟一个接口处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle4</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//借助于带超时的context来实现对函数的超时控制</span></span><br><span class="line">	<span class="comment">//调用cancel()或到达超时时间都将关闭ctx.Done()对应的管道</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), Timeout)</span><br><span class="line">	<span class="keyword">defer</span> cancel() <span class="comment">//纯粹出于良好习惯，函数退出前调用cancel()</span></span><br><span class="line">	workDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//把要控制超时的函数放到一个协程里</span></span><br><span class="line">		LongTimeWork()</span><br><span class="line">		workDone &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123; <span class="comment">//下面的case只执行最早到来的那一个</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-workDone:</span><br><span class="line">		fmt.Println(<span class="string">&quot;LongTimeWork return&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//ctx.Done()是一个管道，context超时或者调用了cancel()都会关闭这个管道，然后读操作就会立即返回</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;LongTimeWork timeout&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Handle1()</span><br><span class="line">	Handle2()</span><br><span class="line">	Handle3()</span><br><span class="line">	Handle4()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协程泄漏">协程泄漏</h2>
<p>  协程阻塞，未能如期结束，导致协程数量不断攀升的现象称为协程泄漏。协程阻塞最常见的原因都跟channel有关。由于每个协程都要占用内存，所以协程泄漏也会导致内存泄漏。<br>
routine_leaky.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟一个耗时较长的任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Duration(<span class="number">500</span>) * time.Millisecond)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟一个接口处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//借助于带超时的context来实现对函数的超时控制</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class="number">100</span>) <span class="comment">//改成1000试试</span></span><br><span class="line">	<span class="keyword">defer</span> cancel()                                                                 <span class="comment">//纯粹出于良好习惯，函数退出前调用cancel()</span></span><br><span class="line">	<span class="comment">// begin := time.Now()</span></span><br><span class="line">	workDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">//创建一个无缓冲管道</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                     <span class="comment">//启动一个子协程</span></span><br><span class="line">		work()</span><br><span class="line">		workDone &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">//work()结束后到，走到这行代码会一直阻塞，子协程无法结束，导致协程泄漏</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123; <span class="comment">//下面的case只执行最早到来的那一个</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-workDone: <span class="comment">//永远执行不到</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;LongTimeWork return&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//ctx.Done()是一个管道，context超时或者调用了cancel()都会关闭这个管道，然后读操作就会立即返回</span></span><br><span class="line">		<span class="comment">// fmt.Printf(&quot;LongTimeWork timeout %d ms\n&quot;, time.Since(begin).Milliseconds())</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		handle()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)                      <span class="comment">//等所有work()结束</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;当前协程数：%d\n&quot;</span>, runtime.NumGoroutine()) <span class="comment">//11，10个阻塞的子协程 加 main协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在以上代码中workDone是同步管道，子协程向workDone里send数据时总是会阻塞（如果每次都超时的话），子协程因阻塞而一直不能退出，导致子协程数量不断累积。<br>
  下面讲排查协程泄漏的方法。首先在一个端口上开启http监听：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;localhost:8080&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  上述代码在8080端口上开启了监听，那我们在本地把程序跑起来，然后在浏览器上访问127.0.0.1:8080/debug/pprof/goroutine?debug=1。</p>
<img src=./leak1.png width=900 />  
<p>  从截图上我们看到协程数量确实多得超出预期，并且明确提示出源代码第25行导致了内存泄漏。还可以通过go tool pprof定位协程泄漏，在终端运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof http://0.0.0.0:8080/debug/pprof/goroutine</span><br></pre></td></tr></table></figure>
<img src=./leak2.png width=800 />  
<p>  注意上面截图中显示生成了一个文件/Users/zhangchaoyang/pprof/pprof.goroutine.001.pb.gz，后面我们会用到它。从截图可以看到main.handle.func1创建的协程最多，通过list命令查看这个函数里到底是哪行代码导致的协程泄漏</p>
<img src=./leak3.png width=900 /> 
<p>  也可能通过traces打印调用堆栈，下面截图显示main.handle.func1由于调用了chansend1而阻塞了1132个协程。</p>
<img src=./leak4.png width=400 /> 
<p>  在pprof中输入web命令，相当于是traces命令的可视化。</p>
<img src=./leak5.png width=500 />   
<p>  其实终端执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof --http=:8081 /Users/zhangchaoyang/pprof/pprof.goroutine.001.pb.gz  </span><br></pre></td></tr></table></figure>
<p>在source view下可看到哪行代码生成的协程最多。</p>
<img src=./leak6.png width=700 /> 
<h2 id="协程管理">协程管理</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(<span class="number">2</span>)	<span class="comment">//分配2个逻辑处理器给调度器使用</span></span><br><span class="line">runtime.Gosched()	<span class="comment">//当前goroutine从当前线程退出，并放回到队列</span></span><br><span class="line">runtime.NumGoroutine()	<span class="comment">//查看当前存在的协程数</span></span><br></pre></td></tr></table></figure>
<p>  通过带缓冲的channel可以实现对goroutine数量的控制。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Glimit <span class="keyword">struct</span> &#123;</span><br><span class="line">	limit <span class="type">int</span></span><br><span class="line">	ch    <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGlimit</span><span class="params">(limit <span class="type">int</span>)</span></span> *Glimit &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Glimit&#123;</span><br><span class="line">		limit: limit,</span><br><span class="line">		ch:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, limit), <span class="comment">//缓冲长度为limit，运行的协程不会超过这个值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Glimit)</span></span> Run(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	g.ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">//创建子协程前往管道里send一个数据</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		f()</span><br><span class="line">		&lt;-g.ch <span class="comment">//子协程退出时从管理里取出一个数据</span></span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">//每隔1秒打印一次协程数量</span></span><br><span class="line">		ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-ticker.C</span><br><span class="line">			fmt.Printf(<span class="string">&quot;当前协程数：%d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	work := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">//do something</span></span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">	glimit := NewGlimit(<span class="number">10</span>) <span class="comment">//限制协程数为10</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		glimit.Run(work) <span class="comment">//不停地通过Run创建子协程</span></span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  守护协程：独立于控制终端和用户请求的协程，它一直存在，周期性执行某种任务或等待处理某些发生的事件。伴随着main协程的退出，守护协程也退出。<br>
  kill命令不是杀死进程，它只是向进程发送信号kill –s pid，s的默认值是15。常见的终止信号如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">信号</th>
<th style="text-align:center">值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SIGINT</td>
<td style="text-align:center">2</td>
<td style="text-align:center">Ctrl+C触发</td>
</tr>
<tr>
<td style="text-align:center">SIGKILL</td>
<td style="text-align:center">9</td>
<td style="text-align:center">无条件结束程序，不能捕获、阻塞或忽略</td>
</tr>
<tr>
<td style="text-align:center">SIGTERM</td>
<td style="text-align:center">15</td>
<td style="text-align:center">结束程序，可以捕获、阻塞或忽略</td>
</tr>
</tbody>
</table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br></pre></td></tr></table></figure>
<p>  当Context的deadline到期或调用了CancelFunc后，Context的Done()管道会关闭，该管道上关联的读操作会解除阻塞，然后执行协程退出前的清理工作。<br>
  下面的代码演示了如何优雅地退出守护协程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	wg     sync.WaitGroup</span><br><span class="line">	ctx    context.Context</span><br><span class="line">	cancle context.CancelFunc</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg = sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">3</span>)                                              <span class="comment">//3个子协程，1个用于接收终止信号，其他2个是业务需要的后台协程</span></span><br><span class="line">	ctx, cancle = context.WithCancel(context.Background()) <span class="comment">//父context</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listenSignal</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	<span class="comment">//监听指定信号 SIGINT和SIGTERM。按下control+c向进程发送SIGINT信号</span></span><br><span class="line">	signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//调用cancle()时，管道ctx.Done()会被关闭，从ctx.Done()中读数据会立即返回0值</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> sig := &lt;-c: <span class="comment">//接收到终止信息</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;got signal %d\n&quot;</span>, sig)</span><br><span class="line">			cancle() <span class="comment">//取消，通知用到ctx的所有协程</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listenHttp</span><span class="params">(port <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	server := &amp;http.Server&#123;Addr: <span class="string">&quot;:&quot;</span> + strconv.Itoa(port), Handler: <span class="literal">nil</span>&#125; <span class="comment">//在端口port上开启http服务</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				server.Close() <span class="comment">//调用Close后才会释放端口</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">if</span> err := server.ListenAndServe(); err != <span class="literal">nil</span> &#123; <span class="comment">//如果不发生error，该行代码会一直阻塞，直到server.Close()</span></span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;stop listen on port %d\n&quot;</span>, port)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//下面3个协程关联到了同一个context，通过cancle()可以通知彼此</span></span><br><span class="line">	<span class="keyword">go</span> listenSignal()</span><br><span class="line">	<span class="keyword">go</span> listenHttp(<span class="number">8080</span>)</span><br><span class="line">	<span class="keyword">go</span> listenHttp(<span class="number">8081</span>)</span><br><span class="line">	wg.Wait() <span class="comment">//等待3个子协程优雅退出后，main协程再退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="案例-4">案例</h2>
<h3 id="并发读写文件">并发读写文件</h3>
<p>3个线程三个文件写入channel，1个协程读取写入文件，不要求文件顺序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lineChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10000</span>)</span><br><span class="line"><span class="keyword">var</span> writeDone = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFiles</span><span class="params">(fileName <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	f, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	r := bufio.NewReader(f)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		s, err2 := r.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err2 == io.EOF &#123;</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span> &#123;</span><br><span class="line">					s += <span class="string">&quot;\n&quot;</span></span><br><span class="line">					lineChan &lt;- s</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			log.Fatal(err2)</span><br><span class="line">		&#125;</span><br><span class="line">		lineChan &lt;- s</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFiles</span><span class="params">(fileName <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(writeDone)</span><br><span class="line">	f, err := os.OpenFile(fileName, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0644</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	w := bufio.NewWriter(f)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> line, ok := &lt;-lineChan; ok &#123;</span><br><span class="line">			w.WriteString(line)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	w.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		fileName := <span class="string">&quot;dir/&quot;</span> + strconv.Itoa(i)</span><br><span class="line">		<span class="keyword">go</span> ReadFiles(fileName)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> WriteFiles(<span class="string">&quot;dir/merge&quot;</span>)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="comment">// 所有读协程完成后关闭通道</span></span><br><span class="line">	<span class="built_in">close</span>(lineChan)</span><br><span class="line">	<span class="comment">// 利用同步管道阻塞写协程</span></span><br><span class="line">	&lt;-writeDone</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://renm.cc">ren_mcc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://renm.cc/20230105/golang-20230105-golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">https://renm.cc/20230105/golang-20230105-golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://renm.cc" target="_blank">ren_mccの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a></div><div class="post-share"><div class="social-share" data-image="/img/yuanshen/avatar/8f16e2511e864f01955f9659b351ee21!400x400.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/20230112/golang-20230112-golang%E6%A0%87%E5%87%86%E5%BA%93http/" title="golang标准库http"><img class="cover" src="/img/yuanshen/avatar/TlrgVdsCp2SJUDmtMPjWGwc9aa6318b6680cd0a4f9b6e523f013df.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">golang标准库http</div></div><div class="info-2"><div class="info-item-1">http协议  http：超文本传输协议Hyper Text Transfer Protocol。 http属于应用层协议，它在传输层用的是tcp协议。 无状态，对事务处理没有记忆能力（对比TCP协议里的确认号）。如果要保存状态需要引用其他技术，如cookie。 无连接，每次连接只处理一个请求。早期带宽和计算资源有限，这么做是为了追求传输速度快，后来通过Connection: Keep-Alive实现长连接。http1.1废弃了Keep-Alive，默认支持长连接。   ...</div></div></div></a><a class="pagination-related" href="/20230104/golang-20230104-golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="golang数据结构与算法"><img class="cover" src="/img/yuanshen/avatar/20210501094038_14f7d.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">golang数据结构与算法</div></div><div class="info-2"><div class="info-item-1">链表 链表是一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，链表有多种实现方法，如单链表、双链表等 在Go语言中，链表使用 container/list 包来实现，内部的实现原理是双链表，链表能够高效地进行任意位置的元素插入和删除操作。    初始化列表 list 的初始化有两种方法：分别是使用 New() 函数和 var 关键字声明，两种方法的初始化效果都是一致的。  通过 container/list 包的 New() 函数初始化 list  1变量名 := list.New()  通过 var 关键字声明初始化 list  1var 变量名 list.List 链表与切片和 map 不同的是，链表并没有具体元素类型的限制，因此，链表的元素可以是任意类型，这既带来了便利，也引来一些问题，例如给链表中放入了一个 interface{} 类型的值，取出值后，如果要将 interface{} 转换为其他类型将会发生宕机。  在链表中插入元素 双链表支持从队列前方或后方插入元素，分别对应的方法是 PushFront 和...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/20221125/golang-20221125-golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="golang基础语法"><img class="cover" src="/img/yuanshen/avatar/b7fd5266d01609241b7224facde357f3e4cd34ed.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang基础语法</div></div><div class="info-2"><div class="info-item-1">标识符与关键字   go变量、常量、自定义类型、包、函数的命名方式必须遵循以下规则：  首字符可以是任意Unicode字符或下划线。 首字符之外的部分可以是Unicode字符、下划线或数字。 名字的长度无限制。   理论上名字里可以有汉字，甚至可以全是汉字，但实际中不要这么做。  Go语言关键字 1break  default  func  interface  select  case  defer  go  map  struct  chan  else  goto  package  switch  const  if  range  type  continue  for  import  return  fallthrough  var 常量 1true  false  iota  nil    数据类型 1int  int8  int16  int32  int64  uint  uint8  uint16  uint32  uint64  uintptr  float32  float64  complex128  complex64  bool  byte ...</div></div></div></a><a class="pagination-related" href="/20221202/golang-20221202-golang%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/" title="golang格式化输出"><img class="cover" src="/img/yuanshen/avatar/97400f365b0b47cf8533d9d0b4ebe150!400x400.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="info-item-2">golang格式化输出</div></div><div class="info-2"><div class="info-item-1">12345type WebSite struct &#123;	Name string&#125;var site = WebSite&#123;Name: &quot;ren123&quot;&#125; 普通占位符    占位符 说明 举例 输出     %v 相应值的默认格式 fmt.Printf(“site: %v\n”, site) site: {ren123}   %#v 响应值的Go语法表示 fmt.Printf(“site: %#v\n”, site) site: main.WebSite{Name:“ren123”}   %T 相应值的类型的Go语法表示 fmt.Printf(“site: %T\n”, site) site: main.WebSite   %% 字面上的百分号，并非值的占位符 fmt.Printf(“site: %%\n”, site) site: %    布尔占位符    占位符 说明 举例 输出     %t 单词true或false fmt.Printf(“b: %t\n”, b) b:...</div></div></div></a><a class="pagination-related" href="/20221125/golang-20221125-golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="golang数据类型"><img class="cover" src="/img/yuanshen/avatar/20210501094041_26fef.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang数据类型</div></div><div class="info-2"><div class="info-item-1">数据类型概览 基础数据类型    类型 长度(字节) 默认值 说明     bool 1 false    byte 1 0 uint8，取值范围[0,255]   rune 4 0 Unicode Code Point, int32   int, uint 4或8 0 32 或 64 位，取决于操作系统   int8, uint8 1 0 -128 ~ 127, 0 ~ 255   int16, uint16 2 0 -32768 ~ 32767, 0 ~ 65535   int32, uint32 4 0 -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名   int64, uint64 8 0    float32 4 0.0    float64 8 0.0    complex64 8     complex128 16     uintptr 4或8  以存储指针的 uint32 或 uint64...</div></div></div></a><a class="pagination-related" href="/20221125/golang-20221125-golang%E7%AE%80%E4%BB%8B/" title="golang简介"><img class="cover" src="/img/yuanshen/avatar/72e25032ecca4e50849950cec4efd821.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang简介</div></div><div class="info-2"><div class="info-item-1">Go语言发展历史 阵容豪华的创使人团队 Ken Thompson  1966年：加入了贝尔实验室，在参与 Multics （多路信息计算）开发期间，创造出了B语言，并用一个月的时间用B语言开发了全新的操作系统UNICS，后来改名为我们所熟悉的UNIX 操作系统。 1971年：和丹尼斯·利奇（Dennis Ritchie）一起共同发明了C语言。 1973年：和丹尼斯·利奇（Dennis Ritchie）使用C语言重写了UNIX，并安装于PDP-11的机器之上。 1983年：美国计算机协会将图灵奖授予汤普森。 2000年：离开贝尔实验室，已退休的汤普森成为了一名飞行员。 2006年：加入Google工作。 2007年：64岁的高龄，与Rob Pike和Robert Griesemer主导了Go语言的开发。  Rob Pike  Go语言项目总负责人。 贝尔实验室Unix团队成员，参与的项目包括Plan 9，Inferno操作系统和Limbo编程语言。 UTF-8字符集规范唯二的发明人之一（另一位是Ken...</div></div></div></a><a class="pagination-related" href="/20221203/golang-20221203-golang%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="golang流程控制"><img class="cover" src="/img/yuanshen/avatar/d1a20cf431adcbef7f6fa3648c4b4cd4a2cc9f62.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-03</div><div class="info-item-2">golang流程控制</div></div><div class="info-2"><div class="info-item-1">if 123if 5 &gt; 9 &#123;    fmt.Println(&quot;5&gt;9&quot;)&#125;  如果逻辑表达式成立，就会执行{}里的内容。 逻辑表达式不需要加()。 &quot;{&quot;必须紧跟在逻辑表达式后面，不能另起一行。  123if c, d, e := 5, 9, 2; c &lt; d &amp;&amp; (c &gt; e || c &gt; 3) &#123; //初始化多个局部变量。复杂的逻辑表达式    fmt.Println(&quot;fit&quot;)&#125;  逻辑表达中可以含有变量或常量。 if句子中允许包含1个(仅1个)分号，在分号前初始化一些局部变量(即只在if块内可见)。  if-else的用法 12345678910color := &quot;black&quot;if color == &quot;red&quot; &#123; //if只能有一个    fmt.Println(&quot;stop&quot;)&#125; else if color ==...</div></div></div></a><a class="pagination-related" href="/20221211/golang-20221209-golang%E5%8C%85%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96/" title="golang包与工程化"><img class="cover" src="/img/yuanshen/avatar/b7fd5266d01609241b7224facde357f3e4cd34ed.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-11</div><div class="info-item-2">golang包与工程化</div></div><div class="info-2"><div class="info-item-1">用go mod管理工程   初始化项目: 1go mod init $module_name $module_name和目录名可以不一样。上述命令会生成go.mod文件，该文件内容形如： 12345678module go-coursego 1.17require (    github.com/ethereum/go-ethereum v1.10.8    github.com/gin-gonic/gin v1.7.4)   Go依次从当前项目、GOROOT、GOPATH下寻找依赖包。  从当前go文件所在的目录逐级向上查找go.mod文件（假设go.mod位于目录mode_path下），里面定义了module_name，则引入包的路径为&quot;module_name/包相对于mode_path的路径&quot;。 go标准库提供的包在GOROOT/src下。 第三方依赖包在GOPATH/pkg/mod下。    从go1.7开始，go get只负责下载第三方依赖包，并把它加到go.mod文件里，由go install负责安装二进制文件。  go get...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">并发模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Goroutine%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">Goroutine的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-number">3.</span> <span class="toc-text">Channel的同步与异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">并发安全性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">多路复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%B3%84%E6%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">协程泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">协程管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-4"><span class="toc-number">8.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">8.1.</span> <span class="toc-text">并发读写文件</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By ren_mcc</div><div class="footer_custom_text"><a rel="noopener external nofollow noreferrer noopener" target="_blank" href="https://beian.miit.gov.cn/"> <img class="icp-icon entered loading" alt="ICP" src="/img/icp.png" data-ll-status><span>京ICP备2022001205号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: [''],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '8265a9279dbd9c8f230ba335aa5ad466'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><div class="aplayer no-destroy" data-id="7211977673" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="list" data-preload="none" data-autoplay="false" muted></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/docker/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 docker (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/docker-compose/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 docker-compose (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/containerd/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 containerd (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/kubernetes/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 kubernetes (27)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/python/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 python (37)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/golang/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 golang (38)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 redis (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/kafka/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 kafka (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://renm.cc/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><!-- hexo injector body_end end --></body></html>