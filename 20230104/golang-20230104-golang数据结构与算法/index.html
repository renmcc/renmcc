<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>golang数据结构与算法 | ren_mccの博客</title><meta name="author" content="ren_mcc"><meta name="copyright" content="ren_mcc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="链表 链表是一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，链表有多种实现方法，如单链表、双链表等 在Go语言中，链表使用 container&#x2F;list 包来实现，内部的实现原理是双链表，链表能够高效地进行任意位置的元素插入和删除操作。    初始化列表 list 的初始化有两种方法：分别是使用 New() 函数和 var 关键字声明，两种方法的初始化效果都是一致的。">
<meta property="og:type" content="article">
<meta property="og:title" content="golang数据结构与算法">
<meta property="og:url" content="https://renm.cc/20230104/golang-20230104-golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="ren_mccの博客">
<meta property="og:description" content="链表 链表是一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，链表有多种实现方法，如单链表、双链表等 在Go语言中，链表使用 container&#x2F;list 包来实现，内部的实现原理是双链表，链表能够高效地进行任意位置的元素插入和删除操作。    初始化列表 list 的初始化有两种方法：分别是使用 New() 函数和 var 关键字声明，两种方法的初始化效果都是一致的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://renm.cc/img/yuanshen/avatar/20210501094038_14f7d.webp">
<meta property="article:published_time" content="2023-01-04T10:32:51.000Z">
<meta property="article:modified_time" content="2023-06-28T13:47:21.761Z">
<meta property="article:author" content="ren_mcc">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://renm.cc/img/yuanshen/avatar/20210501094038_14f7d.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://renm.cc/20230104/golang-20230104-golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'golang数据结构与算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><script src="/js/jquery.min.js"></script><link rel="stylesheet" href="/js/function.min.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="/js/custom.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg" style="background-image: url(/img/backgroud7.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar2.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">148</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/yuanshen/avatar/20210501094038_14f7d.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ren_mccの博客</span></a><a class="nav-page-title" href="/"><span class="site-name">golang数据结构与算法</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">golang数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-04T10:32:51.000Z" title="发表于 2023-01-04 18:32:51">2023-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-28T13:47:21.761Z" title="更新于 2023-06-28 21:47:21">2023-06-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/golang/">golang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2023-06-28 21:47:21&quot;}" hidden></div><h2 id="链表">链表</h2>
<p>链表是一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，链表有多种实现方法，如单链表、双链表等<br>
在Go语言中，链表使用 container/list 包来实现，内部的实现原理是双链表，链表能够高效地进行任意位置的元素插入和删除操作。</p>
<img src=./单双向链表.png width=800 />  
<h3 id="初始化列表">初始化列表</h3>
<p>list 的初始化有两种方法：分别是使用 New() 函数和 var 关键字声明，两种方法的初始化效果都是一致的。</p>
<ol>
<li>通过 container/list 包的 New() 函数初始化 list</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 := list.New()</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过 var 关键字声明初始化 list</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 list.List</span><br></pre></td></tr></table></figure>
<div class="note warning no-icon flat"><p>链表与切片和 map 不同的是，链表并没有具体元素类型的限制，因此，链表的元素可以是任意类型，这既带来了便利，也引来一些问题，例如给链表中放入了一个 interface{} 类型的值，取出值后，如果要将 interface{} 转换为其他类型将会发生宕机。</p>
</div>
<h3 id="在链表中插入元素">在链表中插入元素</h3>
<p>双链表支持从队列前方或后方插入元素，分别对应的方法是 PushFront 和 PushBack。</p>
<div class="note warning no-icon flat"><p><strong>提示</strong><br>
这两个方法都会返回一个 *list.Element 结构，如果在以后的使用中需要删除插入的元素，则只能通过 *list.Element 配合 Remove() 方法进行删除，这种方法可以让删除更加效率化，同时也是双链表特性之一。</p>
</div>
<p>下面代码展示如何给 list 添加元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line">l.PushBack(<span class="string">&quot;fist&quot;</span>)</span><br><span class="line">l.PushFront(<span class="number">67</span>)</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，创建一个链表实例。</li>
<li>第 3 行，将 fist 字符串插入到列表的尾部，此时列表是空的，插入后只有一个元素。</li>
<li>第 4 行，将数值 67 放入列表，此时，列表中已经存在 fist 元素，67 这个元素将被放在 fist 的前面。</li>
</ul>
<p>链表插入元素的方法如下表所示。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>InsertAfter(v interface {}, mark * Element) * Element</td>
<td>在 mark 点之后插入元素，mark 点由其他插入函数提供</td>
</tr>
<tr>
<td>InsertBefore(v interface {}, mark * Element) *Element</td>
<td>在 mark 点之前插入元素，mark 点由其他插入函数提供</td>
</tr>
<tr>
<td>PushBackList(other *List)</td>
<td>添加 other 列表元素到尾部</td>
</tr>
<tr>
<td>PushFrontList(other *List)</td>
<td>添加 other 列表元素到头部</td>
</tr>
</tbody>
</table>
<h3 id="从链表中删除元素">从链表中删除元素</h3>
<p>链表插入函数的返回值会提供一个 *list.Element 结构，这个结构记录着列表元素的值以及与其他节点之间的关系等信息，从链表中删除元素时，需要用到这个结构进行快速删除。</p>
<p>列表操作元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l := list.New()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾部添加</span></span><br><span class="line">    l.PushBack(<span class="string">&quot;canon&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头部添加</span></span><br><span class="line">    l.PushFront(<span class="number">67</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾部添加后保存元素句柄</span></span><br><span class="line">    element := l.PushBack(<span class="string">&quot;fist&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fist之后添加high</span></span><br><span class="line">    l.InsertAfter(<span class="string">&quot;high&quot;</span>, element)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fist之前添加noon</span></span><br><span class="line">    l.InsertBefore(<span class="string">&quot;noon&quot;</span>, element)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用</span></span><br><span class="line">    l.Remove(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，创建列表实例。</li>
<li>第 9 行，将字符串 canon 插入到列表的尾部。</li>
<li>第 12 行，将数值 67 添加到列表的头部。</li>
<li>第 15 行，将字符串 fist 插入到列表的尾部，并将这个元素的内部结构保存到 element 变量中。</li>
<li>第 18 行，使用 element 变量，在 element 的位置后面插入 high 字符串。</li>
<li>第 21 行，使用 element 变量，在 element 的位置前面插入 noon 字符串。</li>
<li>第 24 行，移除 element 变量对应的元素。</li>
</ul>
<p>下表中展示了每次操作后列表的实际元素情况。</p>
<p>列表元素操作的过程</p>
<table>
<thead>
<tr>
<th>操作内容</th>
<th>列表元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>l.PushBack(“canon”)</td>
<td>canon</td>
</tr>
<tr>
<td>l.PushFront(67)</td>
<td>67, canon</td>
</tr>
<tr>
<td>element := l.PushBack(“fist”)</td>
<td>67, canon, fist</td>
</tr>
<tr>
<td>l.InsertAfter(“high”, element)</td>
<td>67, canon, fist, high</td>
</tr>
<tr>
<td>l.InsertBefore(“noon”, element)</td>
<td>67, canon, noon, fist, high</td>
</tr>
<tr>
<td>l.Remove(element)</td>
<td>67, canon, noon, high</td>
</tr>
</tbody>
</table>
<h3 id="遍历列表">遍历列表</h3>
<p>访问列表的每一个元素</p>
<p>遍历双链表需要配合 Front() 函数获取头元素，遍历时只要元素不为空就可以继续进行，每一次遍历都会调用元素的 Next() 函数，代码如下所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"><span class="comment">// 尾部添加</span></span><br><span class="line">l.PushBack(<span class="string">&quot;canon&quot;</span>)</span><br><span class="line"><span class="comment">// 头部添加</span></span><br><span class="line">l.PushFront(<span class="number">67</span>)</span><br><span class="line"><span class="keyword">for</span> i := l.Front(); i != <span class="literal">nil</span>; i = i.Next() &#123;</span><br><span class="line">    fmt.Println(i.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码输出如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">67</span></span><br><span class="line">canon</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，创建一个列表实例。</li>
<li>第 4 行，将 canon 放入列表尾部。</li>
<li>第 7 行，在队列头部放入 67。</li>
<li>第 9 行，使用 for 语句进行遍历，其中 i:=l.Front() 表示初始赋值，只会在一开始执行一次，每次循环会进行一次 i != nil 语句判断，如果返回 false，表示退出循环，反之则会执行 i = i.Next()。</li>
<li>第 10 行，使用遍历返回的 *list.Element 的 Value 成员取得放入列表时的原值。</li>
</ul>
<h3 id="循环链表">循环链表</h3>
<img src=./循环链表.png width=600 /> 
<p>  ring的应用：基于滑动窗口的统计。比如最近100次接口调用的平均耗时、最近10笔订单的平均值、最近30个交易日股票的最高点。ring的容量即为滑动窗口的大小，把待观察变量按时间顺序不停地写入ring即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/ring&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//必须指定长度，各元素被初始化为nil</span></span><br><span class="line">	ring := ring.New(<span class="number">5</span>)</span><br><span class="line">	<span class="comment">// 链表中插入元素</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		ring.Value = i</span><br><span class="line">		ring = ring.Next()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过Do()来遍历ring，内部实际上调用了Next()而非Prev()</span></span><br><span class="line">	ring.Do(<span class="function"><span class="keyword">func</span><span class="params">(a any)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;a: %v\n&quot;</span>, a)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用案例">应用案例</h3>
<p>  LRU(Least Recently Used, 最近最少使用)缓存淘汰的总体思路：缓存的key放到链表中，头部的元素表示最近刚使用。</p>
<ul>
<li>如果命中缓存，从链表中找到对应的key，移到链表头部。</li>
<li>如果没命中缓存：
<ul>
<li>如果缓存容量没超，放入缓存，并把key放到链表头部。</li>
<li>如果超出缓存容量，删除链表尾部元素，再把key放到链表头部。</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	cache <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line">	lst   list.List</span><br><span class="line">	Cap   <span class="type">int</span> <span class="comment">//缓存容量的上限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLRUCache</span><span class="params">(<span class="built_in">cap</span> <span class="type">int</span>)</span></span> *LRUCache &#123;</span><br><span class="line">	lru := <span class="built_in">new</span>(LRUCache)</span><br><span class="line">	lru.Cap = <span class="built_in">cap</span></span><br><span class="line">	lru.cache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>, <span class="built_in">cap</span>)</span><br><span class="line">	lru.lst = list.List&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> lru</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> Add(key <span class="type">int</span>, value <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(lru.cache) &lt; lru.Cap &#123; <span class="comment">//还没有到达缓存容量上限</span></span><br><span class="line">		<span class="comment">//直接把key value放到缓存中去</span></span><br><span class="line">		lru.cache[key] = value</span><br><span class="line">		lru.lst.PushFront(key)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//刚刚到达缓存容量上限</span></span><br><span class="line">		<span class="comment">//先从缓存中淘汰一个元素</span></span><br><span class="line">		back := lru.lst.Back()</span><br><span class="line">		<span class="built_in">delete</span>(lru.cache, back.Value.(<span class="type">int</span>)) <span class="comment">//interface &#123;&#125; is nil, not int</span></span><br><span class="line">		lru.lst.Remove(back)</span><br><span class="line">		<span class="comment">//然后再把key value放到缓存中去</span></span><br><span class="line">		lru.cache[key] = value</span><br><span class="line">		lru.lst.PushFront(key)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> find(key <span class="type">int</span>) *list.Element &#123;</span><br><span class="line">	<span class="keyword">if</span> lru.lst.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	head := lru.lst.Front()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> head.Value.(<span class="type">int</span>) == key &#123;</span><br><span class="line">			<span class="keyword">return</span> head</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			head = head.Next()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> Get(key <span class="type">int</span>) (<span class="type">string</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	value, exists := lru.cache[key]</span><br><span class="line">	ele := lru.find(key)</span><br><span class="line">	<span class="keyword">if</span> ele != <span class="literal">nil</span> &#123;</span><br><span class="line">		lru.lst.MoveToFront(ele)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value, exists</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLRU</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lru := NewLRUCache(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		lru.Add(i, strconv.Itoa(i)) <span class="comment">//9 8 7 6 5 4 3 2 1 0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">		lru.Get(i) <span class="comment">//8 6 4 2 0 9 7 5 3 1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">10</span>; i &lt; <span class="number">15</span>; i++ &#123;</span><br><span class="line">		lru.Add(i, strconv.Itoa(i)) <span class="comment">//14 13 12 11 10 8 6 4 2 0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		_, exists := lru.Get(i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;key %d exists %t\n&quot;</span>, i, exists) <span class="comment">//9 7 5 3 1不存在，8 6 4 2 0存在</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	testLRU()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>key 0 exists true<br>
key 1 exists false<br>
key 2 exists true<br>
key 3 exists false<br>
key 4 exists true<br>
key 5 exists false<br>
key 6 exists true<br>
key 7 exists false<br>
key 8 exists true<br>
key 9 exists false</p>
<h2 id="栈">栈</h2>
<p>  栈是一种先进后出的数据结构，push把元素压入栈底，pop弹出栈顶的元素。编程语言的编译系统也用到了栈的思想。</p>
<img src=./栈.png width=600 /> 
<p>  go自带的List已经包含了栈的功能，这里实现一个线程安全的栈。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	node <span class="keyword">struct</span> &#123;</span><br><span class="line">		value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">		prev  *node</span><br><span class="line">	&#125;</span><br><span class="line">	MyStack <span class="keyword">struct</span> &#123;</span><br><span class="line">		top    *node</span><br><span class="line">		length <span class="type">int</span></span><br><span class="line">		lock   *sync.RWMutex</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyStack</span><span class="params">()</span></span> *MyStack &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MyStack&#123;<span class="literal">nil</span>, <span class="number">0</span>, &amp;sync.RWMutex&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *MyStack)</span></span> Push(value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	stack.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> stack.lock.Unlock()</span><br><span class="line">	n := &amp;node&#123;value, stack.top&#125;</span><br><span class="line">	stack.top = n</span><br><span class="line">	stack.length++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *MyStack)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	stack.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> stack.lock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> stack.length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	n := stack.top</span><br><span class="line">	stack.top = n.prev</span><br><span class="line">	stack.length--</span><br><span class="line">	<span class="keyword">return</span> n.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *MyStack)</span></span> Peak() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	stack.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> stack.lock.RUnlock()</span><br><span class="line">	<span class="keyword">if</span> stack.length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> stack.top.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *MyStack)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> stack.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *MyStack)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> stack.Len() == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈应用">栈应用</h3>
<p>利用栈容器实现斐波那契序列计算<br>
11235813…</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(n <span class="type">int</span>, stack *list.List)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	stack.PushBack(<span class="number">1</span>)</span><br><span class="line">	stack.PushBack(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">		a := stack.Back()</span><br><span class="line">		stack.Remove(a)</span><br><span class="line">		b := stack.Back()</span><br><span class="line">		stack.Remove(b)</span><br><span class="line">		stack.PushBack(a.Value.(<span class="type">int</span>))</span><br><span class="line">		stack.PushBack(a.Value.(<span class="type">int</span>) + b.Value.(<span class="type">int</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	ret := stack.Back().Value.(<span class="type">int</span>)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l := list.New()</span><br><span class="line">	i := Fib(<span class="number">5000</span>, l)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;i: %v\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="堆">堆</h2>
<p>  堆是一棵二叉树。大根堆即任意节点的值都大于等于其子节点。反之为小根堆。<br>
  用数组来表示堆，下标为 i 的结点的父结点下标为(i-1)/2，其左右子结点分别为 (2i + 1)、(2i + 2)。</p>
<img src=./堆的底层实现.png width=600 />  
<p>构建堆</p>
<img src=./构建堆.png width=650 />   
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//AdjustTraingle 如果只是修改slice里的元素，不需要传slice的指针；如果要往slice里append或让slice指向新的子切片，则需要传slice指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdjustTraingle</span><span class="params">(arr []<span class="type">int</span>, parent <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	left := <span class="number">2</span>*parent + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> left &gt;= <span class="built_in">len</span>(arr) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	right := <span class="number">2</span>*parent + <span class="number">2</span></span><br><span class="line">	minIndex := parent</span><br><span class="line">	minValue := arr[minIndex]</span><br><span class="line">	<span class="keyword">if</span> arr[left] &lt; minValue &#123;</span><br><span class="line">		minValue = arr[left]</span><br><span class="line">		minIndex = left</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> right &lt; <span class="built_in">len</span>(arr) &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[right] &lt; minValue &#123;</span><br><span class="line">			minValue = arr[right]</span><br><span class="line">			minIndex = right</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> minIndex != parent &#123;</span><br><span class="line">		arr[minIndex], arr[parent] = arr[parent], arr[minIndex]</span><br><span class="line">		AdjustTraingle(arr, minIndex) <span class="comment">//递归。每当有元素调整下来时，要对以它为父节点的三角形区域进行调整</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseAdjust</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	lastIndex := n / <span class="number">2</span> * <span class="number">2</span></span><br><span class="line">	fmt.Println(lastIndex)</span><br><span class="line">	<span class="keyword">for</span> i := lastIndex; i &gt; <span class="number">0</span>; i -= <span class="number">2</span> &#123; <span class="comment">//逆序检查每一个三角形区域</span></span><br><span class="line">		right := i</span><br><span class="line">		parent := (right - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">		fmt.Println(parent)</span><br><span class="line">		AdjustTraingle(arr, parent)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildHeap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="type">int</span>&#123;<span class="number">62</span>, <span class="number">40</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">49</span>&#125;</span><br><span class="line">	ReverseAdjust(arr)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  每当有元素调整下来时，要对以它为父节点的三角形区域进行调整。</p>
<p>插入元素</p>
<img src=./插入元素.png width=650 />   
<p>删除堆顶</p>
<img src=./删除堆顶.png width=650 />  
<p>下面讲几个堆的应用。<br>
堆排序</p>
<ol>
<li>构建堆O(N)。</li>
<li>不断地删除堆顶O(NlogN)。</li>
</ol>
<p>求集合中最大的K个元素</p>
<ol>
<li>用集合的前K个元素构建小根堆。</li>
<li>逐一遍历集合的其他元素，如果比堆顶小直接丢弃；否则替换掉堆顶，然后向下调整堆。</li>
</ol>
<p>把超时的元素从缓存中删除</p>
<ol>
<li>按key的到期时间把key插入小根堆中。</li>
<li>周期扫描堆顶元素，如果它的到期时间早于当前时刻，则从堆和缓存中删除，然后向下调整堆。<br>
  golang中的container/heap实现了小根堆，但需要自己定义一个类，实现以下接口：</li>
</ol>
<ul>
<li>Len() int</li>
<li>Less(i, j int) bool</li>
<li>Swap(i, j int)</li>
<li>Push(x interface{})</li>
<li>Pop() x interface{}</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value    <span class="type">string</span></span><br><span class="line">	priority <span class="type">int</span> <span class="comment">//优先级，数字越大，优先级越高</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(pq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pq[i].priority &gt; pq[j].priority <span class="comment">//golang默认提供的是小根堆，而优先队列是大根堆，所以这里要反着定义Less</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往slice里append,需要传slice指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	item := x.(*Item)</span><br><span class="line">	*pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让slice指向新的子切片，需要传slice指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	old := *pq</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	item := old[n<span class="number">-1</span>]   <span class="comment">//数组最后一个元素</span></span><br><span class="line">	*pq = old[<span class="number">0</span> : n<span class="number">-1</span>] <span class="comment">//去掉最一个元素</span></span><br><span class="line">	<span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Trie树">Trie树</h2>
<p>  trie树又叫字典权。<br>
  现有term集合：{分散，分散精力，分散投资，分布式，工程，工程师}，把它们放到Trie树里如下图:</p>
<img src=./trie.png width=500 />
<p>  Trie树的根节点是总入口，不存储字符。对于英文，第个节点有26个子节点，子节点可以存到数组里；中文由于汉字很多，用数组存子节点太浪费内存，可以用map存子节点。从根节点到叶节点的完整路径是一个term。从根节点到某个中间节点也可能是一个term，即一个term可能是另一个term的前缀。上图中红圈表示从根节点到本节点是一个完整的term。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TrieNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Word     <span class="type">rune</span>               <span class="comment">//当前节点存储的字符。byte只能表示英文字符，rune可以表示任意字符</span></span><br><span class="line">	Children <span class="keyword">map</span>[<span class="type">rune</span>]*TrieNode <span class="comment">//孩子节点，用一个map存储</span></span><br><span class="line">	Term     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TrieTree <span class="keyword">struct</span> &#123;</span><br><span class="line">	root *TrieNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add 把words[beginIndex:]插入到Trie树中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TrieNode)</span></span> add(words []<span class="type">rune</span>, term <span class="type">string</span>, beginIndex <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> beginIndex &gt;= <span class="built_in">len</span>(words) &#123; <span class="comment">//words已经遍历完了</span></span><br><span class="line">		node.Term = term</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> node.Children == <span class="literal">nil</span> &#123;</span><br><span class="line">		node.Children = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]*TrieNode)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	word := words[beginIndex] <span class="comment">//把这个word放到node的子节点中</span></span><br><span class="line">	<span class="keyword">if</span> child, exists := node.Children[word]; !exists &#123;</span><br><span class="line">		newNode := &amp;TrieNode&#123;Word: word&#125;</span><br><span class="line">		node.Children[word] = newNode</span><br><span class="line">		newNode.add(words, term, beginIndex+<span class="number">1</span>) <span class="comment">//递归</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		child.add(words, term, beginIndex+<span class="number">1</span>) <span class="comment">//递归</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//walk words[0]就是当前节点上存储的字符，按照words的指引顺着树往下走，最终返回words最后一个字符对应的节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TrieNode)</span></span> walk(words []<span class="type">rune</span>, beginIndex <span class="type">int</span>) *TrieNode &#123;</span><br><span class="line">	<span class="keyword">if</span> beginIndex == <span class="built_in">len</span>(words)<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">	&#125;</span><br><span class="line">	beginIndex += <span class="number">1</span></span><br><span class="line">	word := words[beginIndex]</span><br><span class="line">	<span class="keyword">if</span> child, exists := node.Children[word]; exists &#123;</span><br><span class="line">		<span class="keyword">return</span> child.walk(words, beginIndex)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//traverseTerms 遍历一个node下面所有的term。注意要传数组的指针，才能真正修改这个数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TrieNode)</span></span> traverseTerms(terms *[]<span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(node.Term) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		*terms = <span class="built_in">append</span>(*terms, node.Term)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, child := <span class="keyword">range</span> node.Children &#123;</span><br><span class="line">		child.traverseTerms(terms)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *TrieTree)</span></span> AddTerm(term <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(term) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	words := []<span class="type">rune</span>(term)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tree.root == <span class="literal">nil</span> &#123;</span><br><span class="line">		tree.root = <span class="built_in">new</span>(TrieNode)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tree.root.add(words, term, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *TrieTree)</span></span> Retrieve(prefix <span class="type">string</span>) []<span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> tree.root == <span class="literal">nil</span> || <span class="built_in">len</span>(tree.root.Children) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	words := []<span class="type">rune</span>(prefix)</span><br><span class="line">	firstWord := words[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">if</span> child, exists := tree.root.Children[firstWord]; exists &#123;</span><br><span class="line">		end := child.walk(words, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> end == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			terms := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">			end.traverseTerms(&amp;terms)</span><br><span class="line">			<span class="keyword">return</span> terms</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tree := <span class="built_in">new</span>(TrieTree)</span><br><span class="line">	tree.AddTerm(<span class="string">&quot;分散&quot;</span>)</span><br><span class="line">	tree.AddTerm(<span class="string">&quot;分散精力&quot;</span>)</span><br><span class="line">	tree.AddTerm(<span class="string">&quot;分散投资&quot;</span>)</span><br><span class="line">	tree.AddTerm(<span class="string">&quot;分布式&quot;</span>)</span><br><span class="line">	tree.AddTerm(<span class="string">&quot;工程&quot;</span>)</span><br><span class="line">	tree.AddTerm(<span class="string">&quot;工程师&quot;</span>)</span><br><span class="line"></span><br><span class="line">	terms := tree.Retrieve(<span class="string">&quot;分散&quot;</span>)</span><br><span class="line">	fmt.Println(terms)</span><br><span class="line">	terms = tree.Retrieve(<span class="string">&quot;人工&quot;</span>)</span><br><span class="line">	fmt.Println(terms)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://renm.cc">ren_mcc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://renm.cc/20230104/golang-20230104-golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">https://renm.cc/20230104/golang-20230104-golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://renm.cc" target="_blank">ren_mccの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a></div><div class="post-share"><div class="social-share" data-image="/img/yuanshen/avatar/20210501094038_14f7d.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/20230105/golang-20230105-golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="golang并发编程"><img class="cover" src="/img/yuanshen/avatar/8f16e2511e864f01955f9659b351ee21!400x400.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">golang并发编程</div></div><div class="info-2"><div class="info-item-1">并发模型   任何语言的并行，到操作系统层面，都是内核线程的并行。同一个进程内的多个线程共享系统资源，进程的创建、销毁、切换比线程大很多。从进程到线程再到协程, 其实是一个不断共享, 不断减少切换成本的过程。        协程 线程     创建数量 轻松创建上百万个协程而不会导致系统资源衰竭 通常最多不能超过1万个   内存占用 初始分配4k堆栈，随着程序的执行自动增长删除 创建线程时必须指定堆栈且是固定的，通常以M为单位   切换成本 协程切换只需保存三个寄存器，耗时约200纳秒 线程切换需要保存几十个寄存器，耗时约1000纳秒   调度方式 非抢占式，由Go runtime主动交出控制权（对于开发者而言是抢占式） 在时间片用完后，由 CPU 中断任务强行将其调度走，这时必须保存很多信息   创建销毁 goroutine因为是由Go...</div></div></div></a><a class="pagination-related" href="/20230103/golang-20230103-golang%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" title="golang加密算法"><img class="cover" src="/img/yuanshen/avatar/63d9f2d3572c11df029f74b27ec300d9f503c2c7.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">golang加密算法</div></div><div class="info-2"><div class="info-item-1">对称加密    加密过程的每一步都是可逆的。加密和解密用的是同一组密钥。异或是最简单的对称加密算法。 12345678910//XOR 异或运算，要求plain和key的长度相同func XOR(plain string, key []byte) string &#123;	bPlain := []byte(plain)	bCipher := make([]byte, len(key))	for i, k := range key &#123;		bCipher[i] = k ^ bPlain[i]	&#125;	cipher := string(bCipher)	return cipher&#125;   DES（Data Encryption Standard）数据加密标准，是目前最为流行的加密算法之一。对原始数据（明文）进行分组，每组64位，最后一组不足64位时按一定规则填充。每一组上单独施加DES算法。 DES子密钥生成   初始密钥64位，实际有效位56位，每隔7位有一个校验位。根据初始密钥生成16个48位的子密钥。      ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/20221125/golang-20221125-golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="golang基础语法"><img class="cover" src="/img/yuanshen/avatar/b7fd5266d01609241b7224facde357f3e4cd34ed.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang基础语法</div></div><div class="info-2"><div class="info-item-1">标识符与关键字   go变量、常量、自定义类型、包、函数的命名方式必须遵循以下规则：  首字符可以是任意Unicode字符或下划线。 首字符之外的部分可以是Unicode字符、下划线或数字。 名字的长度无限制。   理论上名字里可以有汉字，甚至可以全是汉字，但实际中不要这么做。  Go语言关键字 1break  default  func  interface  select  case  defer  go  map  struct  chan  else  goto  package  switch  const  if  range  type  continue  for  import  return  fallthrough  var 常量 1true  false  iota  nil    数据类型 1int  int8  int16  int32  int64  uint  uint8  uint16  uint32  uint64  uintptr  float32  float64  complex128  complex64  bool  byte ...</div></div></div></a><a class="pagination-related" href="/20221202/golang-20221202-golang%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/" title="golang格式化输出"><img class="cover" src="/img/yuanshen/avatar/97400f365b0b47cf8533d9d0b4ebe150!400x400.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="info-item-2">golang格式化输出</div></div><div class="info-2"><div class="info-item-1">12345type WebSite struct &#123;	Name string&#125;var site = WebSite&#123;Name: &quot;ren123&quot;&#125; 普通占位符    占位符 说明 举例 输出     %v 相应值的默认格式 fmt.Printf(“site: %v\n”, site) site: {ren123}   %#v 响应值的Go语法表示 fmt.Printf(“site: %#v\n”, site) site: main.WebSite{Name:“ren123”}   %T 相应值的类型的Go语法表示 fmt.Printf(“site: %T\n”, site) site: main.WebSite   %% 字面上的百分号，并非值的占位符 fmt.Printf(“site: %%\n”, site) site: %    布尔占位符    占位符 说明 举例 输出     %t 单词true或false fmt.Printf(“b: %t\n”, b) b:...</div></div></div></a><a class="pagination-related" href="/20221125/golang-20221125-golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="golang数据类型"><img class="cover" src="/img/yuanshen/avatar/20210501094041_26fef.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang数据类型</div></div><div class="info-2"><div class="info-item-1">数据类型概览 基础数据类型    类型 长度(字节) 默认值 说明     bool 1 false    byte 1 0 uint8，取值范围[0,255]   rune 4 0 Unicode Code Point, int32   int, uint 4或8 0 32 或 64 位，取决于操作系统   int8, uint8 1 0 -128 ~ 127, 0 ~ 255   int16, uint16 2 0 -32768 ~ 32767, 0 ~ 65535   int32, uint32 4 0 -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名   int64, uint64 8 0    float32 4 0.0    float64 8 0.0    complex64 8     complex128 16     uintptr 4或8  以存储指针的 uint32 或 uint64...</div></div></div></a><a class="pagination-related" href="/20221125/golang-20221125-golang%E7%AE%80%E4%BB%8B/" title="golang简介"><img class="cover" src="/img/yuanshen/avatar/72e25032ecca4e50849950cec4efd821.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang简介</div></div><div class="info-2"><div class="info-item-1">Go语言发展历史 阵容豪华的创使人团队 Ken Thompson  1966年：加入了贝尔实验室，在参与 Multics （多路信息计算）开发期间，创造出了B语言，并用一个月的时间用B语言开发了全新的操作系统UNICS，后来改名为我们所熟悉的UNIX 操作系统。 1971年：和丹尼斯·利奇（Dennis Ritchie）一起共同发明了C语言。 1973年：和丹尼斯·利奇（Dennis Ritchie）使用C语言重写了UNIX，并安装于PDP-11的机器之上。 1983年：美国计算机协会将图灵奖授予汤普森。 2000年：离开贝尔实验室，已退休的汤普森成为了一名飞行员。 2006年：加入Google工作。 2007年：64岁的高龄，与Rob Pike和Robert Griesemer主导了Go语言的开发。  Rob Pike  Go语言项目总负责人。 贝尔实验室Unix团队成员，参与的项目包括Plan 9，Inferno操作系统和Limbo编程语言。 UTF-8字符集规范唯二的发明人之一（另一位是Ken...</div></div></div></a><a class="pagination-related" href="/20221203/golang-20221203-golang%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="golang流程控制"><img class="cover" src="/img/yuanshen/avatar/d1a20cf431adcbef7f6fa3648c4b4cd4a2cc9f62.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-03</div><div class="info-item-2">golang流程控制</div></div><div class="info-2"><div class="info-item-1">if 123if 5 &gt; 9 &#123;    fmt.Println(&quot;5&gt;9&quot;)&#125;  如果逻辑表达式成立，就会执行{}里的内容。 逻辑表达式不需要加()。 &quot;{&quot;必须紧跟在逻辑表达式后面，不能另起一行。  123if c, d, e := 5, 9, 2; c &lt; d &amp;&amp; (c &gt; e || c &gt; 3) &#123; //初始化多个局部变量。复杂的逻辑表达式    fmt.Println(&quot;fit&quot;)&#125;  逻辑表达中可以含有变量或常量。 if句子中允许包含1个(仅1个)分号，在分号前初始化一些局部变量(即只在if块内可见)。  if-else的用法 12345678910color := &quot;black&quot;if color == &quot;red&quot; &#123; //if只能有一个    fmt.Println(&quot;stop&quot;)&#125; else if color ==...</div></div></div></a><a class="pagination-related" href="/20221211/golang-20221209-golang%E5%8C%85%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96/" title="golang包与工程化"><img class="cover" src="/img/yuanshen/avatar/b7fd5266d01609241b7224facde357f3e4cd34ed.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-11</div><div class="info-item-2">golang包与工程化</div></div><div class="info-2"><div class="info-item-1">用go mod管理工程   初始化项目: 1go mod init $module_name $module_name和目录名可以不一样。上述命令会生成go.mod文件，该文件内容形如： 12345678module go-coursego 1.17require (    github.com/ethereum/go-ethereum v1.10.8    github.com/gin-gonic/gin v1.7.4)   Go依次从当前项目、GOROOT、GOPATH下寻找依赖包。  从当前go文件所在的目录逐级向上查找go.mod文件（假设go.mod位于目录mode_path下），里面定义了module_name，则引入包的路径为&quot;module_name/包相对于mode_path的路径&quot;。 go标准库提供的包在GOROOT/src下。 第三方依赖包在GOPATH/pkg/mod下。    从go1.7开始，go get只负责下载第三方依赖包，并把它加到go.mod文件里，由go install负责安装二进制文件。  go get...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.</span> <span class="toc-text">在链表中插入元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.</span> <span class="toc-text">从链表中删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">遍历列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.6.</span> <span class="toc-text">应用案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">2.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%BA%94%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">栈应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">3.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">Trie树</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By ren_mcc</div><div class="footer_custom_text"><a rel="noopener external nofollow noreferrer noopener" target="_blank" href="https://beian.miit.gov.cn/"> <img class="icp-icon entered loading" alt="ICP" src="/img/icp.png" data-ll-status><span>京ICP备2022001205号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: [''],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'f824c611c313646b5fb9f404056be4dc'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><div class="aplayer no-destroy" data-id="7211977673" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="list" data-preload="none" data-autoplay="false" muted></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/docker/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 docker (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/docker-compose/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 docker-compose (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/containerd/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 containerd (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/kubernetes/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 kubernetes (27)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/python/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 python (37)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/golang/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 golang (38)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 redis (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/kafka/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 kafka (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://renm.cc/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><!-- hexo injector body_end end --></body></html>