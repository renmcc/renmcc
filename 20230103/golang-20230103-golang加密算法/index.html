<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>golang加密算法 | ren_mccの博客</title><meta name="author" content="ren_mcc"><meta name="copyright" content="ren_mcc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="对称加密    加密过程的每一步都是可逆的。加密和解密用的是同一组密钥。异或是最简单的对称加密算法。 12345678910&#x2F;&#x2F;XOR 异或运算，要求plain和key的长度相同func XOR(plain string, key []byte) string &amp;#123;	bPlain :&#x3D; []byte(plain)	bCipher :&#x3D; make([]byte, len(key))	for">
<meta property="og:type" content="article">
<meta property="og:title" content="golang加密算法">
<meta property="og:url" content="https://renm.cc/20230103/golang-20230103-golang%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="ren_mccの博客">
<meta property="og:description" content="对称加密    加密过程的每一步都是可逆的。加密和解密用的是同一组密钥。异或是最简单的对称加密算法。 12345678910&#x2F;&#x2F;XOR 异或运算，要求plain和key的长度相同func XOR(plain string, key []byte) string &amp;#123;	bPlain :&#x3D; []byte(plain)	bCipher :&#x3D; make([]byte, len(key))	for">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://renm.cc/img/yuanshen/avatar/63d9f2d3572c11df029f74b27ec300d9f503c2c7.jpeg">
<meta property="article:published_time" content="2023-01-03T15:47:40.000Z">
<meta property="article:modified_time" content="2023-06-28T13:47:21.760Z">
<meta property="article:author" content="ren_mcc">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://renm.cc/img/yuanshen/avatar/63d9f2d3572c11df029f74b27ec300d9f503c2c7.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://renm.cc/20230103/golang-20230103-golang%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'golang加密算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><script src="/js/jquery.min.js"></script><link rel="stylesheet" href="/js/function.min.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="/js/custom.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg" style="background-image: url(/img/backgroud7.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar2.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">148</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/yuanshen/avatar/63d9f2d3572c11df029f74b27ec300d9f503c2c7.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ren_mccの博客</span></a><a class="nav-page-title" href="/"><span class="site-name">golang加密算法</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">golang加密算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-03T15:47:40.000Z" title="发表于 2023-01-03 23:47:40">2023-01-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-28T13:47:21.760Z" title="更新于 2023-06-28 21:47:21">2023-06-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/golang/">golang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2023-06-28 21:47:21&quot;}" hidden></div><h2 id="对称加密">对称加密</h2>
<img src=./对称加密.png width=300 />
<p>  加密过程的每一步都是可逆的。加密和解密用的是同一组密钥。异或是最简单的对称加密算法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XOR 异或运算，要求plain和key的长度相同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">XOR</span><span class="params">(plain <span class="type">string</span>, key []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	bPlain := []<span class="type">byte</span>(plain)</span><br><span class="line">	bCipher := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(key))</span><br><span class="line">	<span class="keyword">for</span> i, k := <span class="keyword">range</span> key &#123;</span><br><span class="line">		bCipher[i] = k ^ bPlain[i]</span><br><span class="line">	&#125;</span><br><span class="line">	cipher := <span class="type">string</span>(bCipher)</span><br><span class="line">	<span class="keyword">return</span> cipher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  DES（Data Encryption Standard）数据加密标准，是目前最为流行的加密算法之一。对原始数据（明文）进行分组，每组64位，最后一组不足64位时按一定规则填充。每一组上单独施加DES算法。<br>
DES子密钥生成<br>
  初始密钥64位，实际有效位56位，每隔7位有一个校验位。根据初始密钥生成16个48位的子密钥。</p>
<img src=./DES子密钥生成.png width=650 />  
<img src=./DES子密钥生成2.png width=650 />   
<p>  N取值从1到16，N和x有固定的映射表。</p>
<p>DES加密过程</p>
<img src=./DES加密过程1.png width=450 />  
<img src=./DES加密过程2.png width=600 />  
<p>  L1, R1 = f(L0, R0, K1)，依此循环，得到L16和R16。<br>
  S盒替换。输入48位，输出32位。各分为8组，输入每组6位，输出每组4位。分别在每组上施加S盒替换，一共8个S盒。</p>
<img src=./S盒替换.png width=650 />   
<p>DES加密过程</p>
<img src=./DES加密过程3.png width=650 />   
<p>  分组模式。CBC（Cipher Block Chaining ）密文分组链接模式，将当前明文分组与前一个密文分组进行异或运算，然后再进行加密。其他分组模式还有ECB, CTR, CFR, OFB。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DesEncryptCBC</span><span class="params">(text <span class="type">string</span>, key []<span class="type">byte</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	src := []<span class="type">byte</span>(text)</span><br><span class="line">	block, err := des.NewCipher(key) <span class="comment">//用des创建一个加密器cipher</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	blockSize := block.BlockSize()           <span class="comment">//分组的大小，blockSize=8</span></span><br><span class="line">	src = common.ZeroPadding(src, blockSize) <span class="comment">//填充</span></span><br><span class="line"></span><br><span class="line">	out := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(src))                   <span class="comment">//密文和明文的长度一致</span></span><br><span class="line">	encrypter := cipher.NewCBCEncrypter(block, key) <span class="comment">//CBC分组模式加密</span></span><br><span class="line">	encrypter.CryptBlocks(out, src)</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(out), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DesDecryptCBC</span><span class="params">(text <span class="type">string</span>, key []<span class="type">byte</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	src, err := hex.DecodeString(text) <span class="comment">//转成[]byte</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	block, err := des.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	out := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(src))                   <span class="comment">//密文和明文的长度一致</span></span><br><span class="line">	encrypter := cipher.NewCBCDecrypter(block, key) <span class="comment">//CBC分组模式解密</span></span><br><span class="line">	encrypter.CryptBlocks(out, src)</span><br><span class="line">	out = common.ZeroUnPadding(out) <span class="comment">//反填充</span></span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(out), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  AES（Advanced Encryption Standard）高级加密标准，旨在取代DES。</p>
<h2 id="非对称加密">非对称加密</h2>
<ul>
<li>使用公钥加密，使用私钥解密。</li>
<li>公钥和私钥不同。</li>
<li>公钥可以公布给所有人。</li>
<li>私钥只有自己保存。</li>
<li>相比于对称加密，运算速度非常慢。</li>
</ul>
<img src=./非对称加密.png width=280 /> 
<p>  对称加密和非对称加密结合使用的案例。小明要给小红传输机密文件，他俩先交换各自的公钥，然后：</p>
<ol>
<li>小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红。</li>
<li>小红用自己的RSA私钥解密得到AES口令。</li>
<li>双方使用这个共享的AES口令用AES加密通信。</li>
</ol>
<img src=./加密通信.png width=500 />   
<p>  RSA是三个发明人名字的缩写：Ron Rivest，Adi Shamir，Leonard Adleman。密钥越长，越难破解。 目前768位的密钥还无法破解（至少没人公开宣布）。因此可以认为1024位的RSA密钥基本安全，2048位的密钥极其安全。RSA的算法原理主要用到了数论。<br>
RSA加密过程</p>
<ol>
<li>随机选择两个不相等的质数p和q。p=61, q=53</li>
<li>计算p和q的乘积n。n=3233</li>
<li>计算n的欧拉函数φ(n) = (p-1)(q-1)。 φ(n) =3120</li>
<li>随机选择一个整数e，使得1&lt; e &lt; φ(n)，且e与φ(n) 互质。e=17</li>
<li>计算e对于φ(n)的模反元素d，即求解e*d+ φ(n)*y=1。d=2753, y=-15</li>
<li>将n和e封装成公钥，n和d封装成私钥。公钥=(3233，17)，公钥=(3233，2753)</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RSA加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaEncrypt</span><span class="params">(origData []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">//解密pem格式的公钥</span></span><br><span class="line">	block, _ := pem.Decode(publicKey)</span><br><span class="line">	<span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;public key error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解析公钥</span></span><br><span class="line">	pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes) <span class="comment">//目前的数字证书一般都是基于ITU（国际电信联盟）制定的X.509标准</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 类型断言</span></span><br><span class="line">	pub := pubInterface.(*rsa.PublicKey)</span><br><span class="line">	<span class="comment">//加密</span></span><br><span class="line">	<span class="keyword">return</span> rsa.EncryptPKCS1v15(rand.Reader, pub, origData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RSA解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaDecrypt</span><span class="params">(ciphertext []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">//解密</span></span><br><span class="line">	block, _ := pem.Decode(privateKey)</span><br><span class="line">	<span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;private key error!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//解析PKCS1格式的私钥</span></span><br><span class="line">	priv, err := x509.ParsePKCS1PrivateKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解密</span></span><br><span class="line">	<span class="keyword">return</span> rsa.DecryptPKCS1v15(rand.Reader, priv, ciphertext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  ECC（Elliptic Curve Cryptography）椭圆曲线加密算法，相比RSA，ECC可以使用更短的密钥，来实现与RSA相当或更高的安全。定义了椭圆曲线上的加法和二倍运算。椭圆曲线依赖的数学难题是：k为正整数，P是椭圆曲线上的点（称为基点）, k*P=Q , 已知Q和P，很难计算出k。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genPrivateKey</span><span class="params">()</span></span> (*ecies.PrivateKey, <span class="type">error</span>) &#123;</span><br><span class="line">	pubkeyCurve := elliptic.P256() <span class="comment">// 初始化椭圆曲线</span></span><br><span class="line">	<span class="comment">// 随机挑选基点,生成私钥</span></span><br><span class="line">	p, err := ecdsa.GenerateKey(pubkeyCurve, rand.Reader) <span class="comment">//用golang标准库生成公私钥对</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ecies.ImportECDSA(p), <span class="literal">nil</span> <span class="comment">//转换成以太坊的公私钥对</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ECCEncrypt 椭圆曲线加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ECCEncrypt</span><span class="params">(plain <span class="type">string</span>, pubKey *ecies.PublicKey)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	src := []<span class="type">byte</span>(plain)</span><br><span class="line">	<span class="keyword">return</span> ecies.Encrypt(rand.Reader, pubKey, src, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ECCDecrypt 椭圆曲线解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ECCDecrypt</span><span class="params">(cipher []<span class="type">byte</span>, prvKey *ecies.PrivateKey)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> src, err := prvKey.Decrypt(cipher, <span class="literal">nil</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">string</span>(src), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希算法">哈希算法</h2>
<p>哈希函数的基本特征</p>
<ol>
<li>输入可以是任意长度。</li>
<li>输出是固定长度。</li>
<li>根据输入很容易计算出输出。</li>
<li>根据输出很难计算出输入（几乎不可能）。</li>
<li>两个不同的输入几乎不可能得到相同的输出。</li>
</ol>
<p>  SHA（Secure Hash Algorithm） 安全散列算法，是一系列密码散列函数，有多个不同安全等级的版本：SHA-1,SHA-224,SHA-256,SHA-384,SHA-512。其作用是防伪装，防窜扰，保证信息的合法性和完整性。<br>
sha-1算法大致过程</p>
<ol>
<li>填充。使得数据长度对512求余的结果为448。</li>
<li>在信息摘要后面附加64bit，表示原始信息摘要的长度。</li>
<li>初始化h0到h4，每个h都是32位。</li>
<li>h0到h4历经80轮复杂的变换。</li>
<li>把h0到h4拼接起来，构成160位，返回。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sha1</span><span class="params">(data <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	sha1 := sha1.New()</span><br><span class="line">	sha1.Write([]<span class="type">byte</span>(data))</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(sha1.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  MD5（Message-Digest Algorithm 5）信息-摘要算法5，算法流程跟SHA-1大体相似。MD5的输出是128位，比SHA-1短了32位。MD5相对易受密码分析的攻击，运算速度比SHA-1快。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Md5</span><span class="params">(data <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	md5 := md5.New()</span><br><span class="line">	md5.Write([]<span class="type">byte</span>(data))</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(md5.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈希函数的应用场景</p>
<ul>
<li>用户密码的存储。</li>
<li>文件上传/下载完整性校验。</li>
<li>mysql大字段的快速对比。<br>
数字签名</li>
</ul>
<img src=./数字签名.png width=550 />   
<p>  比特币中验证交易记录的真实性用的就是数字签名。先hash再用私钥加密的原因是：非对称加密计算量比较大，先hash可以把原始数据转一条很短的信息，提高计算效率。</p>
<h2 id="案例-3">案例</h2>
<h3 id="对称加密AES">对称加密AES</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/aes&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ZeroPadding</span><span class="params">(ciphertext []<span class="type">byte</span>, blockSize <span class="type">int</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	padding := blockSize - <span class="built_in">len</span>(ciphertext)%blockSize</span><br><span class="line">	padtext := bytes.Repeat([]<span class="type">byte</span>&#123;<span class="number">0</span>&#125;, padding) <span class="comment">//用0填充</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(ciphertext, padtext...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZeroUnPadding 这种方法不严谨，末尾的0不一定全是padding出来的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ZeroUnPadding</span><span class="params">(origData []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> bytes.TrimFunc(origData,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> r == <span class="type">rune</span>(<span class="number">0</span>) <span class="comment">//截掉尾部连续的0</span></span><br><span class="line">		&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesEncrypt</span><span class="params">(text <span class="type">string</span>, key []<span class="type">byte</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	blockSize := aes.BlockSize <span class="comment">//AES的分组大小为16</span></span><br><span class="line">	src := []<span class="type">byte</span>(text)</span><br><span class="line">	src = ZeroPadding(src, blockSize) <span class="comment">//填充</span></span><br><span class="line">	encrypted := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(src))</span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	encrypter := cipher.NewCBCEncrypter(block, key) <span class="comment">//CBC分组模式加密</span></span><br><span class="line">	encrypter.CryptBlocks(encrypted, src)</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(encrypted), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesDecrypt</span><span class="params">(text <span class="type">string</span>, key []<span class="type">byte</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	src, err := hex.DecodeString(text) <span class="comment">//转为[]byte</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	decrypted := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(src))</span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	edecrypter := cipher.NewCBCDecrypter(block, key) <span class="comment">//CBC分组模式解密</span></span><br><span class="line">	edecrypter.CryptBlocks(decrypted, src)</span><br><span class="line">	out := ZeroUnPadding(decrypted) <span class="comment">//反填充</span></span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(out), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	key := []<span class="type">byte</span>(<span class="string">&quot;ir489u58ir489u54&quot;</span>) <span class="comment">//key必须是长度为16的byte数组</span></span><br><span class="line">	plain := <span class="string">&quot;因为我们没有什么不同&quot;</span></span><br><span class="line">	cipher, err := AesEncrypt(plain, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;密文：%s\n&quot;</span>, cipher)</span><br><span class="line"></span><br><span class="line">	plain, err = AesDecrypt(cipher, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;明文：%s\n&quot;</span>, plain)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>密文：854deaf62920930fa266eff575fb8fdd8d1473a3ebe345a3ebf87fd4232c1a2f<br>
明文：因为我们没有什么不同</p>
<h3 id="对称加密DES">对称加密DES</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/des&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ZeroPadding</span><span class="params">(ciphertext []<span class="type">byte</span>, blockSize <span class="type">int</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	padding := blockSize - <span class="built_in">len</span>(ciphertext)%blockSize</span><br><span class="line">	padtext := bytes.Repeat([]<span class="type">byte</span>&#123;<span class="number">0</span>&#125;, padding) <span class="comment">//用0填充</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(ciphertext, padtext...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZeroUnPadding 这种方法不严谨，末尾的0不一定全是padding出来的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ZeroUnPadding</span><span class="params">(origData []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> bytes.TrimFunc(origData,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> r == <span class="type">rune</span>(<span class="number">0</span>) <span class="comment">//截掉尾部连续的0</span></span><br><span class="line">		&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DesEncrypt DES加密</span></span><br><span class="line"><span class="comment">// 密钥必须是64位，所以key必须是长度为8的byte数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DesEncrypt</span><span class="params">(text <span class="type">string</span>, key []<span class="type">byte</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	src := []<span class="type">byte</span>(text)</span><br><span class="line">	block, err := des.NewCipher(key) <span class="comment">//用des创建一个加密器cipher</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	blockSize := block.BlockSize()    <span class="comment">//分组的大小，blockSize=8</span></span><br><span class="line">	src = ZeroPadding(src, blockSize) <span class="comment">//填充</span></span><br><span class="line"></span><br><span class="line">	out := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(src)) <span class="comment">//密文和明文的长度一致</span></span><br><span class="line">	dst := out</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(src) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">//分组加密</span></span><br><span class="line">		block.Encrypt(dst, src[:blockSize]) <span class="comment">//对src进行加密，加密结果放到dst里</span></span><br><span class="line">		<span class="comment">//移到下一组</span></span><br><span class="line">		src = src[blockSize:]</span><br><span class="line">		dst = dst[blockSize:]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(out), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DesDecrypt DES解密</span></span><br><span class="line"><span class="comment">// 密钥必须是64位，所以key必须是长度为8的byte数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DesDecrypt</span><span class="params">(text <span class="type">string</span>, key []<span class="type">byte</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	src, err := hex.DecodeString(text) <span class="comment">//转成[]byte</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	block, err := des.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	blockSize := block.BlockSize()</span><br><span class="line">	out := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(src))</span><br><span class="line">	dst := out</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(src) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">//分组解密</span></span><br><span class="line">		block.Decrypt(dst, src[:blockSize])</span><br><span class="line">		src = src[blockSize:]</span><br><span class="line">		dst = dst[blockSize:]</span><br><span class="line">	&#125;</span><br><span class="line">	out = ZeroUnPadding(out) <span class="comment">//反填充</span></span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(out), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DesEncryptCBC</span><span class="params">(text <span class="type">string</span>, key []<span class="type">byte</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	src := []<span class="type">byte</span>(text)</span><br><span class="line">	block, err := des.NewCipher(key) <span class="comment">//用des创建一个加密器cipher</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	blockSize := block.BlockSize()    <span class="comment">//分组的大小，blockSize=8</span></span><br><span class="line">	src = ZeroPadding(src, blockSize) <span class="comment">//填充</span></span><br><span class="line"></span><br><span class="line">	out := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(src))                   <span class="comment">//密文和明文的长度一致</span></span><br><span class="line">	encrypter := cipher.NewCBCEncrypter(block, key) <span class="comment">//CBC分组模式加密</span></span><br><span class="line">	encrypter.CryptBlocks(out, src)</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(out), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DesDecryptCBC</span><span class="params">(text <span class="type">string</span>, key []<span class="type">byte</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	src, err := hex.DecodeString(text) <span class="comment">//转成[]byte</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	block, err := des.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	out := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(src))                   <span class="comment">//密文和明文的长度一致</span></span><br><span class="line">	encrypter := cipher.NewCBCDecrypter(block, key) <span class="comment">//CBC分组模式解密</span></span><br><span class="line">	encrypter.CryptBlocks(out, src)</span><br><span class="line">	out = ZeroUnPadding(out) <span class="comment">//反填充</span></span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(out), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	key := []<span class="type">byte</span>(<span class="string">&quot;ir489u58&quot;</span>) <span class="comment">//key必须是长度为8的byte数组</span></span><br><span class="line">	plain := <span class="string">&quot;因为我们没有什么不同&quot;</span></span><br><span class="line">	cipher, err := DesEncrypt(plain, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;密文：%s\n&quot;</span>, cipher)</span><br><span class="line"></span><br><span class="line">	plain, err = DesDecrypt(cipher, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;明文：%s\n&quot;</span>, plain)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">	cipher, _ = DesEncryptCBC(plain, key)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;密文：%s\n&quot;</span>, cipher)</span><br><span class="line">	plain, err = DesDecryptCBC(cipher, key)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;明文：%s\n&quot;</span>, plain)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>密文：5dc1bc67723d97493e27e5f4993c5a8f743179e15671e34a63067838ce25311f<br>
明文：因为我们没有什么不同<br>
-------------------------------------<br>
密文：3323587cb8e1c03f524cd87fbb0c2585fc71c713f5416cc9ae1ee3ca1350b28d<br>
明文：因为我们没有什么不同</p>
<h3 id="非对称加密ECC">非对称加密ECC</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/ecdsa&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/elliptic&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/ethereum/go-ethereum/crypto/ecies&quot;</span> <span class="comment">//以太坊加密库，要求go版本升级到1.15</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genPrivateKey</span><span class="params">()</span></span> (*ecies.PrivateKey, <span class="type">error</span>) &#123;</span><br><span class="line">	pubkeyCurve := elliptic.P256() <span class="comment">// 初始化椭圆曲线</span></span><br><span class="line">	<span class="comment">// 随机挑选基点,生成私钥</span></span><br><span class="line">	p, err := ecdsa.GenerateKey(pubkeyCurve, rand.Reader) <span class="comment">//用golang标准库生成公私钥对</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ecies.ImportECDSA(p), <span class="literal">nil</span> <span class="comment">//转换成以太坊的公私钥对</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ECCEncrypt 椭圆曲线加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ECCEncrypt</span><span class="params">(plain <span class="type">string</span>, pubKey *ecies.PublicKey)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	src := []<span class="type">byte</span>(plain)</span><br><span class="line">	<span class="keyword">return</span> ecies.Encrypt(rand.Reader, pubKey, src, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ECCDecrypt 椭圆曲线解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ECCDecrypt</span><span class="params">(cipher []<span class="type">byte</span>, prvKey *ecies.PrivateKey)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> src, err := prvKey.Decrypt(cipher, <span class="literal">nil</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">string</span>(src), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	prvKey, err := genPrivateKey()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	pubKey := prvKey.PublicKey</span><br><span class="line">	plain := <span class="string">&quot;因为我们没有什么不同&quot;</span></span><br><span class="line">	cipher, err := ECCEncrypt(plain, &amp;pubKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	plain, err = ECCDecrypt(cipher, prvKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;明文：%s\n&quot;</span>, plain)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="非对称加密RSA">非对称加密RSA</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">生成1024位的RSA私钥：</span></span><br><span class="line"><span class="comment">openssl genrsa -out data/rsa_private_key.pem 1024</span></span><br><span class="line"><span class="comment">根据私钥生成公钥：</span></span><br><span class="line"><span class="comment">openssl rsa -in data/rsa_private_key.pem -pubout -out data/rsa_public_key.pem</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pem是一种标准格式，它通常包含页眉和页脚</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	publicKey  []<span class="type">byte</span></span><br><span class="line">	privateKey []<span class="type">byte</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(keyFile <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> f, err := os.Open(keyFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		content := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4096</span>)</span><br><span class="line">		<span class="keyword">if</span> n, err := f.Read(content); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> content[:n], <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadRSAKey</span><span class="params">(publicKeyFile, privateKeyFile <span class="type">string</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> publicKey, err = ReadFile(publicKeyFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> privateKey, err = ReadFile(privateKeyFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RSA加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaEncrypt</span><span class="params">(origData []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">//解密pem格式的公钥</span></span><br><span class="line">	block, _ := pem.Decode(publicKey)</span><br><span class="line">	<span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;public key error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解析公钥</span></span><br><span class="line">	pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes) <span class="comment">//目前的数字证书一般都是基于ITU（国际电信联盟）制定的X.509标准</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 类型断言</span></span><br><span class="line">	pub := pubInterface.(*rsa.PublicKey)</span><br><span class="line">	<span class="comment">//加密</span></span><br><span class="line">	<span class="keyword">return</span> rsa.EncryptPKCS1v15(rand.Reader, pub, origData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RSA解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaDecrypt</span><span class="params">(ciphertext []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">//解密</span></span><br><span class="line">	block, _ := pem.Decode(privateKey)</span><br><span class="line">	<span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;private key error!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//解析PKCS1格式的私钥</span></span><br><span class="line">	priv, err := x509.ParsePKCS1PrivateKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解密</span></span><br><span class="line">	<span class="keyword">return</span> rsa.DecryptPKCS1v15(rand.Reader, priv, ciphertext)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ReadRSAKey(<span class="string">&quot;D:\\rsa_public_key.pem&quot;</span>, <span class="string">&quot;D:\\rsa_private_key.pem&quot;</span>)</span><br><span class="line"></span><br><span class="line">	plain := <span class="string">&quot;因为我们没有什么不同&quot;</span></span><br><span class="line">	cipher, _ := RsaEncrypt([]<span class="type">byte</span>(plain))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;密文：%s\n&quot;</span>, hex.EncodeToString(cipher))</span><br><span class="line">	bPlain, _ := RsaDecrypt(cipher)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;明文：%s\n&quot;</span>, <span class="type">string</span>(bPlain))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>密文：03eb4e1a6b1444d5996d06e106f126ccb7803a3f3fb4d6ba7751734e410136cc442603b6adcdfaeef2bd7309931fc9f05a404c14ae31fffee7e48808e8b112d630568bbc39ccd5d799f0dfc6e021592c01ed8fac9b618030491813620fe69c891946b21e1dafcd4d8ca3897f6436a85f5548c8bf9e49ef2f13a70f8c0118efeb<br>
明文：因为我们没有什么不同</p>
<h3 id="数字签名验证">数字签名验证</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha1&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(keyFile <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> f, err := os.Open(keyFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		content := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4096</span>)</span><br><span class="line">		<span class="keyword">if</span> n, err := f.Read(content); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> content[:n], <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// go标准库不支持私钥加密，但直接提供了签名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DigitalSignature</span><span class="params">(trade <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	sha1 := sha1.New()</span><br><span class="line">	sha1.Write([]<span class="type">byte</span>(trade))</span><br><span class="line">	digest := sha1.Sum([]<span class="type">byte</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line"></span><br><span class="line">	privateKey, _ := ReadFile(<span class="string">&quot;D:\\rsa_private_key.pem&quot;</span>)</span><br><span class="line">	block, _ := pem.Decode(privateKey)</span><br><span class="line">	priv, _ := x509.ParsePKCS1PrivateKey(block.Bytes)</span><br><span class="line">	<span class="comment">//用私钥生成签名</span></span><br><span class="line">	signature, _ := rsa.SignPKCS1v15(<span class="literal">nil</span>, priv, crypto.Hash(<span class="number">0</span>), digest)</span><br><span class="line">	<span class="keyword">return</span> signature</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证数字签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifySignature</span><span class="params">(trade <span class="type">string</span>, signature []<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	sha1 := sha1.New()</span><br><span class="line">	sha1.Write([]<span class="type">byte</span>(trade))</span><br><span class="line">	digest := sha1.Sum([]<span class="type">byte</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line"></span><br><span class="line">	publicKey, _ := ReadFile(<span class="string">&quot;D:\\rsa_public_key.pem&quot;</span>)</span><br><span class="line">	block, _ := pem.Decode(publicKey)</span><br><span class="line">	pubInterface, _ := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">	pub := pubInterface.(*rsa.PublicKey)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用公钥验证签名</span></span><br><span class="line">	<span class="keyword">return</span> rsa.VerifyPKCS1v15(pub, crypto.Hash(<span class="number">0</span>), digest, signature) == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	trade := <span class="string">&quot;zhangsan transfer 10 BTC to lisi&quot;</span></span><br><span class="line">	signature := DigitalSignature(trade)</span><br><span class="line">	fmt.Println(<span class="string">&quot;验证数字签名&quot;</span>, VerifySignature(trade, signature))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>验证数字签名 true</p>
<h3 id="哈希">哈希</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha1&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sha1</span><span class="params">(data []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	sha1 := sha1.New()</span><br><span class="line">	sha1.Write(data)</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(sha1.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Md5</span><span class="params">(data []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	md5 := md5.New()</span><br><span class="line">	md5.Write(data)</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(md5.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := <span class="string">&quot;因为我们没有什么不同&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;SHA-1: %s\n&quot;</span>, Sha1([]<span class="type">byte</span>(data)))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;MD5: %s\n&quot;</span>, Md5([]<span class="type">byte</span>(data)))</span><br><span class="line"></span><br><span class="line">	f, err := os.Open(<span class="string">&quot;go.sum&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	r := bufio.NewReader(f)</span><br><span class="line">	b, err2 := ioutil.ReadAll(r)</span><br><span class="line">	<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err2)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Sha1(b): %v\n&quot;</span>, Sha1(b))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Md5(b): %v\n&quot;</span>, Md5(b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>SHA-1: 0cfea402af137e3793a6c8a80152b5ab74ba380b<br>
MD5: 78cfcd6021c4f04e7e709cb8148aa4dd<br>
Sha1(b): 4c8180f36e736ae3158767fc2a9f959bb3c86448<br>
Md5(b): c82232187701537f2dd16d5ca836be72</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://renm.cc">ren_mcc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://renm.cc/20230103/golang-20230103-golang%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">https://renm.cc/20230103/golang-20230103-golang%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://renm.cc" target="_blank">ren_mccの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a></div><div class="post-share"><div class="social-share" data-image="/img/yuanshen/avatar/63d9f2d3572c11df029f74b27ec300d9f503c2c7.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/20230104/golang-20230104-golang%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="golang数据结构与算法"><img class="cover" src="/img/yuanshen/avatar/20210501094038_14f7d.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">golang数据结构与算法</div></div><div class="info-2"><div class="info-item-1">链表 链表是一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，链表有多种实现方法，如单链表、双链表等 在Go语言中，链表使用 container/list 包来实现，内部的实现原理是双链表，链表能够高效地进行任意位置的元素插入和删除操作。    初始化列表 list 的初始化有两种方法：分别是使用 New() 函数和 var 关键字声明，两种方法的初始化效果都是一致的。  通过 container/list 包的 New() 函数初始化 list  1变量名 := list.New()  通过 var 关键字声明初始化 list  1var 变量名 list.List 链表与切片和 map 不同的是，链表并没有具体元素类型的限制，因此，链表的元素可以是任意类型，这既带来了便利，也引来一些问题，例如给链表中放入了一个 interface{} 类型的值，取出值后，如果要将 interface{} 转换为其他类型将会发生宕机。  在链表中插入元素 双链表支持从队列前方或后方插入元素，分别对应的方法是 PushFront 和...</div></div></div></a><a class="pagination-related" href="/20221230/golang-20221230-golang%E5%8F%8D%E5%B0%84/" title="golang反射"><img class="cover" src="/img/yuanshen/avatar/100012.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">golang反射</div></div><div class="info-2"><div class="info-item-1">反射介绍   反射就是在运行期间（不是编译期间）探知对象的类型信息和内存结构、更新变量、调用它们的方法。   反射的使用场景：  函数的参数类型是interface{}，需要在运行时对原始类型进行判断，针对不同的类型采取不同的处理方式。比如json.Marshal(v interface{})。 在运行时根据某些条件动态决定调用哪个函数，比如根据配置文件执行相应的算子函数。    Go标准库里的json序列化就使用了反射。 1234567891011type User struct &#123;    Name string    Age int    Sex byte `json:&quot;gender&quot;`&#125;user := User&#123;    Name: &quot;钱钟书&quot;,    Age: 57,    Sex: 1,&#125;json.Marshal(user)  //返回...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/20221125/golang-20221125-golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="golang基础语法"><img class="cover" src="/img/yuanshen/avatar/b7fd5266d01609241b7224facde357f3e4cd34ed.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang基础语法</div></div><div class="info-2"><div class="info-item-1">标识符与关键字   go变量、常量、自定义类型、包、函数的命名方式必须遵循以下规则：  首字符可以是任意Unicode字符或下划线。 首字符之外的部分可以是Unicode字符、下划线或数字。 名字的长度无限制。   理论上名字里可以有汉字，甚至可以全是汉字，但实际中不要这么做。  Go语言关键字 1break  default  func  interface  select  case  defer  go  map  struct  chan  else  goto  package  switch  const  if  range  type  continue  for  import  return  fallthrough  var 常量 1true  false  iota  nil    数据类型 1int  int8  int16  int32  int64  uint  uint8  uint16  uint32  uint64  uintptr  float32  float64  complex128  complex64  bool  byte ...</div></div></div></a><a class="pagination-related" href="/20221202/golang-20221202-golang%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/" title="golang格式化输出"><img class="cover" src="/img/yuanshen/avatar/97400f365b0b47cf8533d9d0b4ebe150!400x400.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="info-item-2">golang格式化输出</div></div><div class="info-2"><div class="info-item-1">12345type WebSite struct &#123;	Name string&#125;var site = WebSite&#123;Name: &quot;ren123&quot;&#125; 普通占位符    占位符 说明 举例 输出     %v 相应值的默认格式 fmt.Printf(“site: %v\n”, site) site: {ren123}   %#v 响应值的Go语法表示 fmt.Printf(“site: %#v\n”, site) site: main.WebSite{Name:“ren123”}   %T 相应值的类型的Go语法表示 fmt.Printf(“site: %T\n”, site) site: main.WebSite   %% 字面上的百分号，并非值的占位符 fmt.Printf(“site: %%\n”, site) site: %    布尔占位符    占位符 说明 举例 输出     %t 单词true或false fmt.Printf(“b: %t\n”, b) b:...</div></div></div></a><a class="pagination-related" href="/20221125/golang-20221125-golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="golang数据类型"><img class="cover" src="/img/yuanshen/avatar/20210501094041_26fef.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang数据类型</div></div><div class="info-2"><div class="info-item-1">数据类型概览 基础数据类型    类型 长度(字节) 默认值 说明     bool 1 false    byte 1 0 uint8，取值范围[0,255]   rune 4 0 Unicode Code Point, int32   int, uint 4或8 0 32 或 64 位，取决于操作系统   int8, uint8 1 0 -128 ~ 127, 0 ~ 255   int16, uint16 2 0 -32768 ~ 32767, 0 ~ 65535   int32, uint32 4 0 -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名   int64, uint64 8 0    float32 4 0.0    float64 8 0.0    complex64 8     complex128 16     uintptr 4或8  以存储指针的 uint32 或 uint64...</div></div></div></a><a class="pagination-related" href="/20221125/golang-20221125-golang%E7%AE%80%E4%BB%8B/" title="golang简介"><img class="cover" src="/img/yuanshen/avatar/72e25032ecca4e50849950cec4efd821.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang简介</div></div><div class="info-2"><div class="info-item-1">Go语言发展历史 阵容豪华的创使人团队 Ken Thompson  1966年：加入了贝尔实验室，在参与 Multics （多路信息计算）开发期间，创造出了B语言，并用一个月的时间用B语言开发了全新的操作系统UNICS，后来改名为我们所熟悉的UNIX 操作系统。 1971年：和丹尼斯·利奇（Dennis Ritchie）一起共同发明了C语言。 1973年：和丹尼斯·利奇（Dennis Ritchie）使用C语言重写了UNIX，并安装于PDP-11的机器之上。 1983年：美国计算机协会将图灵奖授予汤普森。 2000年：离开贝尔实验室，已退休的汤普森成为了一名飞行员。 2006年：加入Google工作。 2007年：64岁的高龄，与Rob Pike和Robert Griesemer主导了Go语言的开发。  Rob Pike  Go语言项目总负责人。 贝尔实验室Unix团队成员，参与的项目包括Plan 9，Inferno操作系统和Limbo编程语言。 UTF-8字符集规范唯二的发明人之一（另一位是Ken...</div></div></div></a><a class="pagination-related" href="/20221203/golang-20221203-golang%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="golang流程控制"><img class="cover" src="/img/yuanshen/avatar/d1a20cf431adcbef7f6fa3648c4b4cd4a2cc9f62.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-03</div><div class="info-item-2">golang流程控制</div></div><div class="info-2"><div class="info-item-1">if 123if 5 &gt; 9 &#123;    fmt.Println(&quot;5&gt;9&quot;)&#125;  如果逻辑表达式成立，就会执行{}里的内容。 逻辑表达式不需要加()。 &quot;{&quot;必须紧跟在逻辑表达式后面，不能另起一行。  123if c, d, e := 5, 9, 2; c &lt; d &amp;&amp; (c &gt; e || c &gt; 3) &#123; //初始化多个局部变量。复杂的逻辑表达式    fmt.Println(&quot;fit&quot;)&#125;  逻辑表达中可以含有变量或常量。 if句子中允许包含1个(仅1个)分号，在分号前初始化一些局部变量(即只在if块内可见)。  if-else的用法 12345678910color := &quot;black&quot;if color == &quot;red&quot; &#123; //if只能有一个    fmt.Println(&quot;stop&quot;)&#125; else if color ==...</div></div></div></a><a class="pagination-related" href="/20221211/golang-20221209-golang%E5%8C%85%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96/" title="golang包与工程化"><img class="cover" src="/img/yuanshen/avatar/b7fd5266d01609241b7224facde357f3e4cd34ed.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-11</div><div class="info-item-2">golang包与工程化</div></div><div class="info-2"><div class="info-item-1">用go mod管理工程   初始化项目: 1go mod init $module_name $module_name和目录名可以不一样。上述命令会生成go.mod文件，该文件内容形如： 12345678module go-coursego 1.17require (    github.com/ethereum/go-ethereum v1.10.8    github.com/gin-gonic/gin v1.7.4)   Go依次从当前项目、GOROOT、GOPATH下寻找依赖包。  从当前go文件所在的目录逐级向上查找go.mod文件（假设go.mod位于目录mode_path下），里面定义了module_name，则引入包的路径为&quot;module_name/包相对于mode_path的路径&quot;。 go标准库提供的包在GOROOT/src下。 第三方依赖包在GOPATH/pkg/mod下。    从go1.7开始，go get只负责下载第三方依赖包，并把它加到go.mod文件里，由go install负责安装二进制文件。  go get...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">1.</span> <span class="toc-text">对称加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">2.</span> <span class="toc-text">非对称加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">哈希算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3"><span class="toc-number">4.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86AES"><span class="toc-number">4.1.</span> <span class="toc-text">对称加密AES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86DES"><span class="toc-number">4.2.</span> <span class="toc-text">对称加密DES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86ECC"><span class="toc-number">4.3.</span> <span class="toc-text">非对称加密ECC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86RSA"><span class="toc-number">4.4.</span> <span class="toc-text">非对称加密RSA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81"><span class="toc-number">4.5.</span> <span class="toc-text">数字签名验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">4.6.</span> <span class="toc-text">哈希</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By ren_mcc</div><div class="footer_custom_text"><a rel="noopener external nofollow noreferrer noopener" target="_blank" href="https://beian.miit.gov.cn/"> <img class="icp-icon entered loading" alt="ICP" src="/img/icp.png" data-ll-status><span>京ICP备2022001205号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: [''],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'cc78ff495b1add7b8ebb534c3c0b7d10'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><div class="aplayer no-destroy" data-id="7211977673" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="list" data-preload="none" data-autoplay="false" muted></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/docker/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 docker (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/docker-compose/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 docker-compose (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/containerd/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 containerd (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/kubernetes/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 kubernetes (27)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/python/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 python (37)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/golang/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 golang (38)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 redis (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/kafka/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 kafka (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://renm.cc/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><!-- hexo injector body_end end --></body></html>