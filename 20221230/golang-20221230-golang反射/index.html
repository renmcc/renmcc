<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>golang反射 | ren_mccの博客</title><meta name="author" content="ren_mcc"><meta name="copyright" content="ren_mcc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="反射介绍   反射就是在运行期间（不是编译期间）探知对象的类型信息和内存结构、更新变量、调用它们的方法。   反射的使用场景：  函数的参数类型是interface{}，需要在运行时对原始类型进行判断，针对不同的类型采取不同的处理方式。比如json.Marshal(v interface{})。 在运行时根据某些条件动态决定调用哪个函数，比如根据配置文件执行相应的算子函数。    Go标准库里的j">
<meta property="og:type" content="article">
<meta property="og:title" content="golang反射">
<meta property="og:url" content="https://renm.cc/20221230/golang-20221230-golang%E5%8F%8D%E5%B0%84/index.html">
<meta property="og:site_name" content="ren_mccの博客">
<meta property="og:description" content="反射介绍   反射就是在运行期间（不是编译期间）探知对象的类型信息和内存结构、更新变量、调用它们的方法。   反射的使用场景：  函数的参数类型是interface{}，需要在运行时对原始类型进行判断，针对不同的类型采取不同的处理方式。比如json.Marshal(v interface{})。 在运行时根据某些条件动态决定调用哪个函数，比如根据配置文件执行相应的算子函数。    Go标准库里的j">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://renm.cc/img/yuanshen/avatar/100012.webp">
<meta property="article:published_time" content="2022-12-30T08:38:30.000Z">
<meta property="article:modified_time" content="2023-06-28T13:47:21.759Z">
<meta property="article:author" content="ren_mcc">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://renm.cc/img/yuanshen/avatar/100012.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://renm.cc/20221230/golang-20221230-golang%E5%8F%8D%E5%B0%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'golang反射',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><script src="/js/jquery.min.js"></script><link rel="stylesheet" href="/js/function.min.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="/js/custom.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg" style="background-image: url(/img/backgroud7.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar2.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">148</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/yuanshen/avatar/100012.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ren_mccの博客</span></a><a class="nav-page-title" href="/"><span class="site-name">golang反射</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">golang反射</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-30T08:38:30.000Z" title="发表于 2022-12-30 16:38:30">2022-12-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-28T13:47:21.759Z" title="更新于 2023-06-28 21:47:21">2023-06-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/golang/">golang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2023-06-28 21:47:21&quot;}" hidden></div><h2 id="反射介绍">反射介绍</h2>
<p>  反射就是在运行期间（不是编译期间）探知对象的类型信息和内存结构、更新变量、调用它们的方法。<br>
  反射的使用场景：</p>
<ul>
<li>函数的参数类型是interface{}，需要在运行时对原始类型进行判断，针对不同的类型采取不同的处理方式。比如json.Marshal(v interface{})。</li>
<li>在运行时根据某些条件动态决定调用哪个函数，比如根据配置文件执行相应的算子函数。</li>
</ul>
<p>  Go标准库里的json序列化就使用了反射。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    Sex <span class="type">byte</span> <span class="string">`json:&quot;gender&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line">user := User&#123;</span><br><span class="line">    Name: <span class="string">&quot;钱钟书&quot;</span>,</span><br><span class="line">    Age: <span class="number">57</span>,</span><br><span class="line">    Sex: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">json.Marshal(user)  <span class="comment">//返回 &#123;&quot;Name&quot;:&quot;钱钟书&quot;,&quot;Age&quot;:57,&quot;gender&quot;:1&#125;</span></span><br></pre></td></tr></table></figure>
<p>  反射的弊端：</p>
<ul>
<li>代码难以阅读，难以维护。</li>
<li>编译期间不能发现类型错误，覆盖测试难度很大，有些bug需要到线上运行很长时间才能发现，可能会造成严重用后果。</li>
<li>反射性能很差，通常比正常代码慢一到两个数量级。在对性能要求很高，或大量反复调用的代码块里建议不要使用反射。</li>
</ul>
<h2 id="反射的基础数据类型">反射的基础数据类型</h2>
<img src=./reflect.png width=750 />  
<p>  reflect.Type用于获取类型相关的信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">	Method(<span class="type">int</span>) Method  <span class="comment">//第i个方法</span></span><br><span class="line">	MethodByName(<span class="type">string</span>) (Method, <span class="type">bool</span>) <span class="comment">//根据名称获取方法</span></span><br><span class="line">	NumMethod() <span class="type">int</span>  <span class="comment">//方法的个数</span></span><br><span class="line">	Name() <span class="type">string</span>   <span class="comment">//获取结构体名称</span></span><br><span class="line">	PkgPath() <span class="type">string</span> <span class="comment">//包路径</span></span><br><span class="line">	Size() <span class="type">uintptr</span>  <span class="comment">//占用内存的大小</span></span><br><span class="line">	String() <span class="type">string</span>  <span class="comment">//获取字符串表述</span></span><br><span class="line">	Kind() Kind  <span class="comment">//数据类型</span></span><br><span class="line">	Implements(u Type) <span class="type">bool</span>  <span class="comment">//判断是否实现了某接口</span></span><br><span class="line">	AssignableTo(u Type) <span class="type">bool</span>  <span class="comment">//能否赋给另外一种类型</span></span><br><span class="line">	ConvertibleTo(u Type) <span class="type">bool</span>  <span class="comment">//能否转换为另外一种类型</span></span><br><span class="line">	Elem() Type  <span class="comment">//解析指针</span></span><br><span class="line">	Field(i <span class="type">int</span>) StructField  <span class="comment">//第i个成员</span></span><br><span class="line">	FieldByIndex(index []<span class="type">int</span>) StructField  <span class="comment">//根据index路径获取嵌套成员</span></span><br><span class="line">	FieldByName(name <span class="type">string</span>) (StructField, <span class="type">bool</span>)  <span class="comment">//根据名称获取成员</span></span><br><span class="line">	FieldByNameFunc(match <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">bool</span>) (StructField, <span class="type">bool</span>)  <span class="comment">//</span></span><br><span class="line">	Len() <span class="type">int</span>  <span class="comment">//容器的长度</span></span><br><span class="line">	NumIn() <span class="type">int</span>  <span class="comment">//输出参数的个数</span></span><br><span class="line">	NumOut() <span class="type">int</span>  <span class="comment">//返回参数的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  通过reflect.Value获取、修改原始数据类型里的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 代表的数据类型</span></span><br><span class="line">	typ *rtype</span><br><span class="line">	<span class="comment">// 指向原始数据的指针</span></span><br><span class="line">	ptr unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反射API">反射API</h2>
<h3 id="reflect-Type">reflect.Type</h3>
<h4 id="如何得到Type">如何得到Type</h4>
<p>通过TypeOf()得到Type类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typeI := reflect.TypeOf(<span class="number">1</span>)       </span><br><span class="line">typeS := reflect.TypeOf(<span class="string">&quot;hello&quot;</span>) </span><br><span class="line">fmt.Println(typeI)               <span class="comment">//int</span></span><br><span class="line">fmt.Println(typeS)               <span class="comment">//string</span></span><br><span class="line"></span><br><span class="line">typeUser := reflect.TypeOf(&amp;common.User&#123;&#125;) </span><br><span class="line">fmt.Println(typeUser)                     <span class="comment">//*common.User</span></span><br><span class="line">fmt.Println(typeUser.Kind())                 <span class="comment">//ptr</span></span><br><span class="line">fmt.Println(typeUser.Elem().Kind())    <span class="comment">//struct</span></span><br></pre></td></tr></table></figure>
<h4 id="指针Type转为非指针Type">指针Type转为非指针Type</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeUser := reflect.TypeOf(&amp;common.User&#123;&#125;) </span><br><span class="line">typeUser2 := reflect.TypeOf(common.User&#123;&#125;)</span><br><span class="line">assert.IsEqual(typeUser.Elem(), typeUser2)</span><br></pre></td></tr></table></figure>
<h4 id="获取struct成员变量的信息">获取struct成员变量的信息</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typeUser := reflect.TypeOf(common.User&#123;&#125;) <span class="comment">//需要用struct的Type，不能用指针的Type</span></span><br><span class="line">fieldNum := typeUser.NumField()           <span class="comment">//成员变量的个数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; fieldNum; i++ &#123;</span><br><span class="line">	field := typeUser.Field(i)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d %s offset %d anonymous %t type %s exported %t json tag %s\n&quot;</span>, i,</span><br><span class="line">		field.Name,            <span class="comment">//变量名称</span></span><br><span class="line">		field.Offset,          <span class="comment">//相对于结构体首地址的内存偏移量，string类型会占据16个字节</span></span><br><span class="line">		field.Anonymous,       <span class="comment">//是否为匿名成员</span></span><br><span class="line">		field.Type,            <span class="comment">//数据类型，reflect.Type类型</span></span><br><span class="line">		field.IsExported(),    <span class="comment">//包外是否可见（即是否以大写字母开头）</span></span><br><span class="line">		field.Tag.Get(<span class="string">&quot;json&quot;</span>)) <span class="comment">//获取成员变量后面``里面定义的tag</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过FieldByName获取Field</span></span><br><span class="line"><span class="keyword">if</span> nameField, ok := typeUser.FieldByName(<span class="string">&quot;Name&quot;</span>); ok &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Name is exported %t\n&quot;</span>, nameField.IsExported())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以根据FieldByIndex获取Field</span></span><br><span class="line">thirdField := typeUser.FieldByIndex([]<span class="type">int</span>&#123;<span class="number">2</span>&#125;) <span class="comment">//参数是个slice，因为有struct嵌套的情况</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;third field name %s\n&quot;</span>, thirdField.Name)</span><br></pre></td></tr></table></figure>
<h4 id="获取struct成员方法的信息">获取struct成员方法的信息</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typeUser := reflect.TypeOf(common.User&#123;&#125;)</span><br><span class="line">methodNum := typeUser.NumMethod() <span class="comment">//成员方法的个数。接收者为指针的方法【不】包含在内</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; methodNum; i++ &#123;</span><br><span class="line">	method := typeUser.Method(i)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;method name:%s ,type:%s, exported:%t\n&quot;</span>, method.Name, method.Type, method.IsExported())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">typeUser2 := reflect.TypeOf(&amp;common.User&#123;&#125;)</span><br><span class="line">methodNum = typeUser2.NumMethod() <span class="comment">//成员方法的个数。接收者为指针或值的方法【都】包含在内，也就是说值实现的方法指针也实现了（反之不成立）</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; methodNum; i++ &#123;</span><br><span class="line">	method := typeUser2.Method(i)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;method name:%s ,type:%s, exported:%t\n&quot;</span>, method.Name, method.Type, method.IsExported())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取函数的信息">获取函数的信息</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeFunc := reflect.TypeOf(Add) <span class="comment">//获取函数类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;is function type %t\n&quot;</span>, typeFunc.Kind() == reflect.Func)</span><br><span class="line">argInNum := typeFunc.NumIn()   <span class="comment">//输入参数的个数</span></span><br><span class="line">argOutNum := typeFunc.NumOut() <span class="comment">//输出参数的个数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; argInNum; i++ &#123;</span><br><span class="line">	argTyp := typeFunc.In(i)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;第%d个输入参数的类型%s\n&quot;</span>, i, argTyp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; argOutNum; i++ &#123;</span><br><span class="line">	argTyp := typeFunc.Out(i)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;第%d个输出参数的类型%s\n&quot;</span>, i, argTyp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断类型是否实现了某接口">判断类型是否实现了某接口</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过reflect.TypeOf((*&lt;interface&gt;)(nil)).Elem()获得接口类型。因为People是个接口不能创建实例，所以把nil强制转为*common.People类型</span></span><br><span class="line">typeOfPeople := reflect.TypeOf((*common.People)(<span class="literal">nil</span>)).Elem()</span><br><span class="line">fmt.Printf(<span class="string">&quot;typeOfPeople kind is interface %t\n&quot;</span>, typeOfPeople.Kind() == reflect.Interface)</span><br><span class="line">t1 := reflect.TypeOf(common.User&#123;&#125;)</span><br><span class="line">t2 := reflect.TypeOf(&amp;common.User&#123;&#125;)</span><br><span class="line"><span class="comment">//如果值类型实现了接口，则指针类型也实现了接口；反之不成立</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;t1 implements People interface %t\n&quot;</span>, t1.Implements(typeOfPeople))</span><br></pre></td></tr></table></figure>
<h3 id="reflect-Value">reflect.Value</h3>
<h4 id="如果获得Value">如果获得Value</h4>
<p>通过ValueOf()得到Value。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iValue := reflect.ValueOf(<span class="number">1</span>)</span><br><span class="line">sValue := reflect.ValueOf(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">userPtrValue := reflect.ValueOf(&amp;common.User&#123;</span><br><span class="line">	Id:     <span class="number">7</span>,</span><br><span class="line">	Name:   <span class="string">&quot;杰克逊&quot;</span>,</span><br><span class="line">	Weight: <span class="number">65</span>,</span><br><span class="line">	Height: <span class="number">1.68</span>,</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(iValue)       <span class="comment">//1</span></span><br><span class="line">fmt.Println(sValue)       <span class="comment">//hello</span></span><br><span class="line">fmt.Println(userPtrValue) <span class="comment">//&amp;&#123;7 杰克逊  65 1.68&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="Value转为Type">Value转为Type</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iType := iValue.Type()</span><br><span class="line">sType := sValue.Type()</span><br><span class="line">userType := userPtrValue.Type()</span><br><span class="line"><span class="comment">//在Type和相应Value上调用Kind()结果一样的</span></span><br><span class="line">fmt.Println(iType.Kind() == reflect.Int, iValue.Kind() == reflect.Int, iType.Kind() == iValue.Kind())  </span><br><span class="line">fmt.Println(sType.Kind() == reflect.String, sValue.Kind() == reflect.String, sType.Kind() == sValue.Kind()) </span><br><span class="line">fmt.Println(userType.Kind() == reflect.Ptr, userPtrValue.Kind() == reflect.Ptr, userType.Kind() == userPtrValue.Kind())</span><br></pre></td></tr></table></figure>
<h4 id="指针Value和非指针Value互相转换">指针Value和非指针Value互相转换</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userValue := userPtrValue.Elem()                    <span class="comment">//Elem() 指针Value转为非指针Value</span></span><br><span class="line">fmt.Println(userValue.Kind(), userPtrValue.Kind())  <span class="comment">//struct ptr</span></span><br><span class="line">userPtrValue3 := userValue.Addr()                   <span class="comment">//Addr() 非指针Value转为指针Value</span></span><br><span class="line">fmt.Println(userValue.Kind(), userPtrValue3.Kind()) <span class="comment">//struct ptr</span></span><br></pre></td></tr></table></figure>
<h4 id="得到Value对应的原始数据">得到Value对应的原始数据</h4>
<p>通过Interface()函数把Value转为interface{}，再从interface{}强制类型转换，转为原始数据类型。或者在Value上直接调用Int()、String()等一步到位。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;origin value iValue is %d %d\n&quot;</span>, iValue.Interface().(<span class="type">int</span>), iValue.Int())</span><br><span class="line">fmt.Printf(<span class="string">&quot;origin value sValue is %s %s\n&quot;</span>, sValue.Interface().(<span class="type">string</span>), sValue.String())</span><br><span class="line">user := userValue.Interface().(common.User)</span><br><span class="line">fmt.Printf(<span class="string">&quot;id=%d name=%s weight=%.2f height=%.2f\n&quot;</span>, user.Id, user.Name, user.Weight, user.Height)</span><br><span class="line">user2 := userPtrValue.Interface().(*common.User)</span><br><span class="line">fmt.Printf(<span class="string">&quot;id=%d name=%s weight=%.2f height=%.2f\n&quot;</span>, user2.Id, user2.Name, user2.Weight, user2.Height)</span><br></pre></td></tr></table></figure>
<h4 id="空Value的判断">空Value的判断</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; <span class="comment">//接口没有指向具体的值</span></span><br><span class="line">v := reflect.ValueOf(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;v持有值 %t, type of v is Invalid %t\n&quot;</span>, v.IsValid(), v.Kind() == reflect.Invalid)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user *common.User = <span class="literal">nil</span></span><br><span class="line">v = reflect.ValueOf(user) <span class="comment">//Value指向一个nil</span></span><br><span class="line"><span class="keyword">if</span> v.IsValid() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;v持有的值是nil %t\n&quot;</span>, v.IsNil()) <span class="comment">//调用IsNil()前先确保IsValid()，否则会panic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u common.User <span class="comment">//只声明，里面的值都是0值</span></span><br><span class="line">v = reflect.ValueOf(u)</span><br><span class="line"><span class="keyword">if</span> v.IsValid() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;v持有的值是对应类型的0值 %t\n&quot;</span>, v.IsZero()) <span class="comment">//调用IsZero()前先确保IsValid()，否则会panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过Value修改原始数据的值">通过Value修改原始数据的值</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line">user := common.User&#123;</span><br><span class="line">	Id:     <span class="number">7</span>,</span><br><span class="line">	Name:   <span class="string">&quot;杰克逊&quot;</span>,</span><br><span class="line">	Weight: <span class="number">65.5</span>,</span><br><span class="line">	Height: <span class="number">1.68</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">valueI := reflect.ValueOf(&amp;i) <span class="comment">//由于go语言所有函数传的都是值，所以要想修改原来的值就需要传指针</span></span><br><span class="line">valueS := reflect.ValueOf(&amp;s)</span><br><span class="line">valueUser := reflect.ValueOf(&amp;user)</span><br><span class="line">valueI.Elem().SetInt(<span class="number">8</span>) <span class="comment">//由于valueI对应的原始对象是指针，通过Elem()返回指针指向的对象</span></span><br><span class="line">valueS.Elem().SetString(<span class="string">&quot;golang&quot;</span>)</span><br><span class="line">valueUser.Elem().FieldByName(<span class="string">&quot;Weight&quot;</span>).SetFloat(<span class="number">68.0</span>) <span class="comment">//FieldByName()通过Name返回类的成员变量</span></span><br></pre></td></tr></table></figure>
<p>强调一下，要想修改原始数据的值，给ValueOf传的必须是指针，而指针Value不能调用Set和FieldByName方法，所以得先通过Elem()转为非指针Value。<br>
未导出成员的值不能通过反射进行修改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addrValue := valueUser.Elem().FieldByName(<span class="string">&quot;addr&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> addrValue.CanSet() &#123;</span><br><span class="line">	addrValue.SetString(<span class="string">&quot;北京&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;addr是未导出成员，不可Set&quot;</span>) <span class="comment">//以小写字母开头的成员相当于是私有成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过Value修改Slice">通过Value修改Slice</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">users := <span class="built_in">make</span>([]*common.User, <span class="number">1</span>, <span class="number">5</span>) <span class="comment">//len=1，cap=5</span></span><br><span class="line">users[<span class="number">0</span>] = &amp;common.User&#123;</span><br><span class="line">	Id:     <span class="number">7</span>,</span><br><span class="line">	Name:   <span class="string">&quot;杰克逊&quot;</span>,</span><br><span class="line">	Weight: <span class="number">65.5</span>,</span><br><span class="line">	Height: <span class="number">1.68</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sliceValue := reflect.ValueOf(&amp;users) <span class="comment">//准备通过Value修改users，所以传users的地址</span></span><br><span class="line"><span class="keyword">if</span> sliceValue.Elem().Len() &gt; <span class="number">0</span> &#123;      <span class="comment">//取得slice的长度</span></span><br><span class="line">	sliceValue.Elem().Index(<span class="number">0</span>).Elem().FieldByName(<span class="string">&quot;Name&quot;</span>).SetString(<span class="string">&quot;令狐一刀&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;1st user name change to %s\n&quot;</span>, users[<span class="number">0</span>].Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至可以修改slice的cap，新的cap必须位于原始的len到cap之间，即只能把cap改小。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sliceValue.Elem().SetCap(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>通过把len改大，可以实现向slice中追加元素的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sliceValue.Elem().SetLen(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//调用reflect.Value的Set()函数修改其底层指向的原始数据</span></span><br><span class="line">sliceValue.Elem().Index(<span class="number">1</span>).Set(reflect.ValueOf(&amp;common.User&#123;</span><br><span class="line">	Id:     <span class="number">8</span>,</span><br><span class="line">	Name:   <span class="string">&quot;李达&quot;</span>,</span><br><span class="line">	Weight: <span class="number">80</span>,</span><br><span class="line">	Height: <span class="number">180</span>,</span><br><span class="line">&#125;))</span><br><span class="line">fmt.Printf(<span class="string">&quot;2nd user name %s\n&quot;</span>, users[<span class="number">1</span>].Name)</span><br></pre></td></tr></table></figure>
<h4 id="修改map">修改map</h4>
<p>Value.SetMapIndex()函数：往map里添加一个key-value对。<br>
Value.MapIndex()函数： 根据Key取出对应的map。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">u1 := &amp;common.User&#123;</span><br><span class="line">	Id:     <span class="number">7</span>,</span><br><span class="line">	Name:   <span class="string">&quot;杰克逊&quot;</span>,</span><br><span class="line">	Weight: <span class="number">65.5</span>,</span><br><span class="line">	Height: <span class="number">1.68</span>,</span><br><span class="line">&#125;</span><br><span class="line">u2 := &amp;common.User&#123;</span><br><span class="line">	Id:     <span class="number">8</span>,</span><br><span class="line">	Name:   <span class="string">&quot;杰克逊&quot;</span>,</span><br><span class="line">	Weight: <span class="number">65.5</span>,</span><br><span class="line">	Height: <span class="number">1.68</span>,</span><br><span class="line">&#125;</span><br><span class="line">userMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*common.User, <span class="number">5</span>)</span><br><span class="line">userMap[u1.Id] = u1</span><br><span class="line"></span><br><span class="line">mapValue := reflect.ValueOf(&amp;userMap)                                                         <span class="comment">//准备通过Value修改userMap，所以传userMap的地址</span></span><br><span class="line">mapValue.Elem().SetMapIndex(reflect.ValueOf(u2.Id), reflect.ValueOf(u2))                      <span class="comment">//SetMapIndex 往map里添加一个key-value对</span></span><br><span class="line">mapValue.Elem().MapIndex(reflect.ValueOf(u1.Id)).Elem().FieldByName(<span class="string">&quot;Name&quot;</span>).SetString(<span class="string">&quot;令狐一刀&quot;</span>) <span class="comment">//MapIndex 根据Key取出对应的map</span></span><br><span class="line"><span class="keyword">for</span> k, user := <span class="keyword">range</span> userMap &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;key %d name %s\n&quot;</span>, k, user.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用函数">调用函数</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">valueFunc := reflect.ValueOf(Add) <span class="comment">//函数也是一种数据类型</span></span><br><span class="line">typeFunc := reflect.TypeOf(Add)</span><br><span class="line">argNum := typeFunc.NumIn()            <span class="comment">//函数输入参数的个数</span></span><br><span class="line">args := <span class="built_in">make</span>([]reflect.Value, argNum) <span class="comment">//准备函数的输入参数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; argNum; i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> typeFunc.In(i).Kind() == reflect.Int &#123;</span><br><span class="line">		args[i] = reflect.ValueOf(<span class="number">3</span>) <span class="comment">//给每一个参数都赋3</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">sumValue := valueFunc.Call(args) <span class="comment">//返回[]reflect.Value，因为go语言的函数返回可能是一个列表</span></span><br><span class="line"><span class="keyword">if</span> typeFunc.Out(<span class="number">0</span>).Kind() == reflect.Int &#123;</span><br><span class="line">	sum := sumValue[<span class="number">0</span>].Interface().(<span class="type">int</span>) <span class="comment">//从Value转为原始数据类型</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;sum=%d\n&quot;</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用成员方法">调用成员方法</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">common.User&#123;</span><br><span class="line">	Id:     <span class="number">7</span>,</span><br><span class="line">	Name:   <span class="string">&quot;杰克逊&quot;</span>,</span><br><span class="line">	Weight: <span class="number">65.5</span>,</span><br><span class="line">	Height: <span class="number">1.68</span>,</span><br><span class="line">&#125;</span><br><span class="line">valueUser := reflect.ValueOf(&amp;user)              <span class="comment">//必须传指针，因为BMI()在定义的时候它是指针的方法</span></span><br><span class="line">bmiMethod := valueUser.MethodByName(<span class="string">&quot;BMI&quot;</span>)       <span class="comment">//MethodByName()通过Name返回类的成员变量</span></span><br><span class="line">resultValue := bmiMethod.Call([]reflect.Value&#123;&#125;) <span class="comment">//无参数时传一个空的切片</span></span><br><span class="line">result := resultValue[<span class="number">0</span>].Interface().(<span class="type">float32</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;bmi=%.2f\n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Think()在定义的时候用的不是指针，valueUser可以用指针也可以不用指针</span></span><br><span class="line">thinkMethod := valueUser.MethodByName(<span class="string">&quot;Think&quot;</span>)</span><br><span class="line">thinkMethod.Call([]reflect.Value&#123;&#125;)</span><br><span class="line"></span><br><span class="line">valueUser2 := reflect.ValueOf(user)</span><br><span class="line">thinkMethod = valueUser2.MethodByName(<span class="string">&quot;Think&quot;</span>)</span><br><span class="line">thinkMethod.Call([]reflect.Value&#123;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="创建对象">创建对象</h3>
<h4 id="创建struct">创建struct</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user :=t := reflect.TypeOf(common.User&#123;&#125;)</span><br><span class="line">value := reflect.New(t) <span class="comment">//根据reflect.Type创建一个对象，得到该对象的指针，再根据指针提到reflect.Value</span></span><br><span class="line">value.Elem().FieldByName(<span class="string">&quot;Id&quot;</span>).SetInt(<span class="number">10</span>)</span><br><span class="line">user := value.Interface().(*common.User) <span class="comment">//把反射类型转成go原始数据类型Call([]reflect.Value&#123;&#125;)</span></span><br></pre></td></tr></table></figure>
<h4 id="创建slice">创建slice</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []common.User</span><br><span class="line">sliceType := reflect.TypeOf(slice)</span><br><span class="line">sliceValue := reflect.MakeSlice(sliceType, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">sliceValue.Index(<span class="number">0</span>).Set(reflect.ValueOf(common.User&#123;</span><br><span class="line">	Id:     <span class="number">8</span>,</span><br><span class="line">	Name:   <span class="string">&quot;李达&quot;</span>,</span><br><span class="line">	Weight: <span class="number">80</span>,</span><br><span class="line">	Height: <span class="number">180</span>,</span><br><span class="line">&#125;))</span><br><span class="line">users := sliceValue.Interface().([]common.User)</span><br><span class="line">fmt.Printf(<span class="string">&quot;1st user name %s\n&quot;</span>, users[<span class="number">0</span>].Name)</span><br></pre></td></tr></table></figure>
<h4 id="创建map">创建map</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userMap <span class="keyword">map</span>[<span class="type">int</span>]*common.User</span><br><span class="line">mapType := reflect.TypeOf(userMap)</span><br><span class="line"><span class="comment">// mapValue:=reflect.MakeMap(mapType)</span></span><br><span class="line">mapValue := reflect.MakeMapWithSize(mapType, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">user := &amp;common.User&#123;</span><br><span class="line">	Id:     <span class="number">7</span>,</span><br><span class="line">	Name:   <span class="string">&quot;杰克逊&quot;</span>,</span><br><span class="line">	Weight: <span class="number">65.5</span>,</span><br><span class="line">	Height: <span class="number">1.68</span>,</span><br><span class="line">&#125;</span><br><span class="line">key := reflect.ValueOf(user.Id)</span><br><span class="line">mapValue.SetMapIndex(key, reflect.ValueOf(user))                    <span class="comment">//SetMapIndex 往map里添加一个key-value对</span></span><br><span class="line">mapValue.MapIndex(key).Elem().FieldByName(<span class="string">&quot;Name&quot;</span>).SetString(<span class="string">&quot;令狐一刀&quot;</span>) <span class="comment">//MapIndex 根据Key取出对应的map</span></span><br><span class="line">userMap = mapValue.Interface().(<span class="keyword">map</span>[<span class="type">int</span>]*common.User)</span><br><span class="line">fmt.Printf(<span class="string">&quot;user name %s %s\n&quot;</span>, userMap[<span class="number">7</span>].Name, user.Name)</span><br></pre></td></tr></table></figure>
<p>reflect包里除了MakeSlice()和MakeMap()，还有MakeChan()和MakeFunc()。</p>
<h2 id="自行实现json序列化">自行实现json序列化</h2>
<p>  所谓序列化即把struct实例转为string。比如定义了User和Book两个struct。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    Sex <span class="type">byte</span> <span class="string">`json:&quot;gender&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    ISBN <span class="type">string</span> <span class="string">`json:&quot;isbn&quot;`</span></span><br><span class="line">    Author User <span class="string">`json:&quot;author&quot;`</span></span><br><span class="line">    Keywords []<span class="type">string</span> <span class="string">`json:&quot;kws&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Book的实例序列化后为</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;isbn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4243547567&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;钱钟书&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;Age&quot;</span><span class="punctuation">:</span> <span class="number">57</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;kws&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;爱情&quot;</span><span class="punctuation">,</span> <span class="string">&quot;民国&quot;</span><span class="punctuation">,</span> <span class="string">&quot;留学&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>  序列化实现思路：</p>
<ul>
<li>从内向外、从简单到复杂地考虑序列化问题。
<ol>
<li>如果要序列化一个int、float、string，很简单。</li>
<li>如果要序列化一个slice，则在第1步的基础上用[]括起来。</li>
<li>如果要序列化一个struct，FieldName直接打印出来，FieldValue的序列化可以参考第1、2步。</li>
<li>如果struct内部还嵌套了struct，则递归调用第3步。</li>
</ol>
</li>
<li>通过反射解析struct，得到json key和struct FieldName的对应关系。</li>
<li>如果FieldValue是基本的值类型，则通过反射给FieldValue赋值很简单。</li>
<li>如果FieldValue是slice类型，则需要通过反射先创建一个slice，再给slice里的每个元素赋值。</li>
<li>如果FieldValue是是内嵌struct，则递归调用反序列化函数，给FieldValue赋值。</li>
<li>如果FieldValue是是内嵌struct指针，则需要创建内嵌struct对应的实例（申请内存空间），再递归调用反序列化函数，给FieldValue赋值。</li>
</ul>
<h2 id="案例-2">案例</h2>
<h3 id="序列化json">序列化json</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">	Sex  <span class="type">byte</span> <span class="string">`json:&quot;gender&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">	ISBN     <span class="type">string</span> <span class="string">`json:&quot;isbn&quot;`</span></span><br><span class="line">	Name     <span class="type">string</span></span><br><span class="line">	Price    <span class="type">float32</span>      <span class="string">`json:&quot;price&quot;`</span></span><br><span class="line">	Author   *User        <span class="string">`json:&quot;author&quot;`</span> <span class="comment">//把指针去掉试试</span></span><br><span class="line">	Keywords []<span class="type">string</span>     <span class="string">`json:&quot;kws&quot;`</span></span><br><span class="line">	Local    <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span> <span class="comment">//暂不支持map</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	value := reflect.ValueOf(v)</span><br><span class="line">	typ := value.Type() <span class="comment">//跟typ := reflect.TypeOf(v)等价</span></span><br><span class="line">	<span class="keyword">if</span> typ.Kind() == reflect.Ptr &#123;</span><br><span class="line">		<span class="keyword">if</span> value.IsNil() &#123; <span class="comment">//如果指向nil，直接输出null</span></span><br><span class="line">			<span class="keyword">return</span> []<span class="type">byte</span>(<span class="string">&quot;null&quot;</span>), <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果传的是指针类型，先解析指针</span></span><br><span class="line">			typ = typ.Elem()</span><br><span class="line">			value = value.Elem()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	bf := bytes.Buffer&#123;&#125; <span class="comment">//存放序列化结果</span></span><br><span class="line">	<span class="keyword">switch</span> typ.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.String:</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;\&quot;%s\&quot;&quot;</span>, value.String())), <span class="literal">nil</span> <span class="comment">//取得reflect.Value对应的原始数据的值</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Bool:</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%t&quot;</span>, value.Bool())), <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Float32,</span><br><span class="line">		reflect.Float64:</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, value.Float())), <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Uint,</span><br><span class="line">		reflect.Uint8,</span><br><span class="line">		reflect.Uint16,</span><br><span class="line">		reflect.Uint32,</span><br><span class="line">		reflect.Uint64,</span><br><span class="line">		reflect.Int,</span><br><span class="line">		reflect.Int8,</span><br><span class="line">		reflect.Int16,</span><br><span class="line">		reflect.Int32,</span><br><span class="line">		reflect.Int64:</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, value.Interface())), <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Slice:</span><br><span class="line">		<span class="keyword">if</span> value.IsValid() &amp;&amp; value.IsNil() &#123;</span><br><span class="line">			<span class="keyword">return</span> []<span class="type">byte</span>(<span class="string">&quot;null&quot;</span>), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		bf.WriteByte(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> value.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; value.Len(); i++ &#123; <span class="comment">//取得slice的长度</span></span><br><span class="line">				<span class="keyword">if</span> bs, err := Marshal(value.Index(i).Interface()); err != <span class="literal">nil</span> &#123; <span class="comment">//对slice的第i个元素进行序列化。递归</span></span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					bf.Write(bs)</span><br><span class="line">					bf.WriteByte(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bf.Truncate(<span class="built_in">len</span>(bf.Bytes()) - <span class="number">1</span>) <span class="comment">//删除最后一个逗号</span></span><br><span class="line">		&#125;</span><br><span class="line">		bf.WriteByte(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> bf.Bytes(), <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Map:</span><br><span class="line">		<span class="keyword">if</span> value.IsValid() &amp;&amp; value.IsNil() &#123;</span><br><span class="line">			<span class="keyword">return</span> []<span class="type">byte</span>(<span class="string">&quot;null&quot;</span>), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		bf.WriteByte(<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> value.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> _, key := <span class="keyword">range</span> value.MapKeys() &#123;</span><br><span class="line">				<span class="keyword">if</span> keyBs, err := Marshal(key.Interface()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					bf.WriteByte(<span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">					bf.Write(keyBs)</span><br><span class="line">					bf.WriteByte(<span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">					bf.WriteByte(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">					v := value.MapIndex(key)</span><br><span class="line">					<span class="keyword">if</span> vBs, err := Marshal(v.Interface()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						bf.Write(vBs)</span><br><span class="line">						bf.WriteByte(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bf.Truncate(<span class="built_in">len</span>(bf.Bytes()) - <span class="number">1</span>) <span class="comment">//删除最后一个逗号</span></span><br><span class="line">		&#125;</span><br><span class="line">		bf.WriteByte(<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> bf.Bytes(), <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Struct:</span><br><span class="line">		bf.WriteByte(<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> value.NumField() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; value.NumField(); i++ &#123;</span><br><span class="line">				fieldValue := value.Field(i)</span><br><span class="line">				fieldType := typ.Field(i)</span><br><span class="line">				<span class="keyword">if</span> fieldType.IsExported() &#123;</span><br><span class="line">					name := fieldType.Name <span class="comment">//如果没有json Tag，默认使用成员变量的名称</span></span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(fieldType.Tag.Get(<span class="string">&quot;json&quot;</span>)) &gt; <span class="number">0</span> &#123;</span><br><span class="line">						name = fieldType.Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">					&#125;</span><br><span class="line">					bf.WriteString(<span class="string">&quot;\&quot;&quot;</span>)</span><br><span class="line">					bf.WriteString(name)</span><br><span class="line">					bf.WriteString(<span class="string">&quot;\&quot;&quot;</span>)</span><br><span class="line">					bf.WriteString(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">					<span class="keyword">if</span> bs, err := Marshal(fieldValue.Interface()); err != <span class="literal">nil</span> &#123; <span class="comment">//对value递归调用Marshal序列化</span></span><br><span class="line">						<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						bf.Write(bs)</span><br><span class="line">					&#125;</span><br><span class="line">					bf.WriteString(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bf.Truncate(<span class="built_in">len</span>(bf.Bytes()) - <span class="number">1</span>) <span class="comment">//删除最后一个逗号</span></span><br><span class="line">		&#125;</span><br><span class="line">		bf.WriteByte(<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> bf.Bytes(), <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;\&quot;暂不支持该数据类型:%s\&quot;&quot;</span>, typ.Kind().String())), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	book := Book&#123;</span><br><span class="line">		ISBN:     <span class="string">&quot;4243547567&quot;</span>,</span><br><span class="line">		Name:     <span class="string">&quot;围城&quot;</span>,</span><br><span class="line">		Price:    <span class="number">34.8</span>,</span><br><span class="line">		Author:   &amp;User&#123;Name: <span class="string">&quot;钱钟书&quot;</span>, Age: <span class="number">55</span>, Sex: <span class="number">1</span>&#125;, <span class="comment">//改成nil试试</span></span><br><span class="line">		Keywords: []<span class="type">string</span>&#123;<span class="string">&quot;爱情&quot;</span>, <span class="string">&quot;民国&quot;</span>, <span class="string">&quot;留学&quot;</span>&#125;,          <span class="comment">//把这一行注释掉试一下，测测null</span></span><br><span class="line">		Local:    <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;<span class="number">2</span>: <span class="literal">true</span>, <span class="number">3</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b, err := Marshal(book); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;序列化失败: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="type">string</span>(b))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：<br>
{“isbn”:“4243547567”,“Name”:“围城”,“price”:34.799999,“author”:{“Name”:“钱钟书”,“Age”:55,“gender”:1},“kws”:[“爱情”,“民国”,“留学”],“Local”:{“2”:true,“3”:false}}</p>
<h3 id="反序列化json">反序列化json</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">	Sex  <span class="type">byte</span> <span class="string">`json:&quot;gender&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">	ISBN     <span class="type">string</span> <span class="string">`json:&quot;isbn&quot;`</span></span><br><span class="line">	Name     <span class="type">string</span></span><br><span class="line">	Price    <span class="type">float32</span>      <span class="string">`json:&quot;price&quot;`</span></span><br><span class="line">	Author   *User        <span class="string">`json:&quot;author&quot;`</span> <span class="comment">//把指针去掉试试</span></span><br><span class="line">	Keywords []<span class="type">string</span>     <span class="string">`json:&quot;kws&quot;`</span></span><br><span class="line">	Local    <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span> <span class="comment">//暂不支持map</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于json字符串里存在&#123;&#125;[]等嵌套情况，直接按,分隔是不合适的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitJson</span><span class="params">(json <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	rect := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">	stack := list.New() <span class="comment">//list是双端队列，用它来模拟栈</span></span><br><span class="line">	beginIndex := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, r := <span class="keyword">range</span> json &#123;</span><br><span class="line">		<span class="keyword">if</span> r == <span class="type">rune</span>(<span class="string">&#x27;&#123;&#x27;</span>) || r == <span class="type">rune</span>(<span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">			stack.PushBack(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;) <span class="comment">//我们不关心栈里是什么，只关心栈里有没有元素</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> r == <span class="type">rune</span>(<span class="string">&#x27;&#125;&#x27;</span>) || r == <span class="type">rune</span>(<span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">			ele := stack.Back()</span><br><span class="line">			<span class="keyword">if</span> ele != <span class="literal">nil</span> &#123;</span><br><span class="line">				stack.Remove(ele) <span class="comment">//删除栈顶元素</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> r == <span class="type">rune</span>(<span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> stack.Len() == <span class="number">0</span> &#123; <span class="comment">//栈为空时才可以按,分隔</span></span><br><span class="line">				rect = <span class="built_in">append</span>(rect, json[beginIndex:i])</span><br><span class="line">				beginIndex = i + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rect = <span class="built_in">append</span>(rect, json[beginIndex:])</span><br><span class="line">	<span class="keyword">return</span> rect</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="type">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	s := <span class="type">string</span>(data)</span><br><span class="line">	<span class="comment">//去除前后的连续空格</span></span><br><span class="line">	s = strings.TrimLeft(s, <span class="string">&quot; &quot;</span>)</span><br><span class="line">	s = strings.TrimRight(s, <span class="string">&quot; &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	typ := reflect.TypeOf(v)</span><br><span class="line">	value := reflect.ValueOf(v)</span><br><span class="line">	<span class="keyword">if</span> typ.Kind() != reflect.Ptr &#123; <span class="comment">//因为要修改v，必须传指针</span></span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;must pass pointer parameter&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	typ = typ.Elem() <span class="comment">//解析指针</span></span><br><span class="line">	value = value.Elem()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> typ.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.String:</span><br><span class="line">		<span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;&quot;&#x27;</span> &amp;&amp; s[<span class="built_in">len</span>(s)<span class="number">-1</span>] == <span class="string">&#x27;&quot;&#x27;</span> &#123;</span><br><span class="line">			value.SetString(s[<span class="number">1</span> : <span class="built_in">len</span>(s)<span class="number">-1</span>]) <span class="comment">//去除前后的&quot;&quot;</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// return errors.New(fmt.Sprintf(&quot;invalid json part: %s&quot;, s))</span></span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid json part: %s&quot;</span>, s)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Bool:</span><br><span class="line">		<span class="keyword">if</span> b, err := strconv.ParseBool(s); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			value.SetBool(b)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Float32,</span><br><span class="line">		reflect.Float64:</span><br><span class="line">		<span class="keyword">if</span> f, err := strconv.ParseFloat(s, <span class="number">64</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			value.SetFloat(f) <span class="comment">//通过reflect.Value修改原始数据的值</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Int,</span><br><span class="line">		reflect.Int8,</span><br><span class="line">		reflect.Int16,</span><br><span class="line">		reflect.Int32,</span><br><span class="line">		reflect.Int64:</span><br><span class="line">		<span class="keyword">if</span> i, err := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">64</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			value.SetInt(i) <span class="comment">//有符号整型通过SetInt</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Uint,</span><br><span class="line">		reflect.Uint8,</span><br><span class="line">		reflect.Uint16,</span><br><span class="line">		reflect.Uint32,</span><br><span class="line">		reflect.Uint64:</span><br><span class="line">		<span class="keyword">if</span> i, err := strconv.ParseUint(s, <span class="number">10</span>, <span class="number">64</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			value.SetUint(i) <span class="comment">//无符号整型需要通过SetUint</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Slice:</span><br><span class="line">		<span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;[&#x27;</span> &amp;&amp; s[<span class="built_in">len</span>(s)<span class="number">-1</span>] == <span class="string">&#x27;]&#x27;</span> &#123;</span><br><span class="line">			arr := SplitJson(s[<span class="number">1</span> : <span class="built_in">len</span>(s)<span class="number">-1</span>]) <span class="comment">//去除前后的[]</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(arr) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				slice := reflect.ValueOf(v).Elem()                    <span class="comment">//别忘了，v是指针</span></span><br><span class="line">				slice.Set(reflect.MakeSlice(typ, <span class="built_in">len</span>(arr), <span class="built_in">len</span>(arr))) <span class="comment">//通过反射创建slice</span></span><br><span class="line">				<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">					eleValue := slice.Index(i)</span><br><span class="line">					eleType := eleValue.Type()</span><br><span class="line">					<span class="keyword">if</span> eleType.Kind() != reflect.Ptr &#123;</span><br><span class="line">						eleValue = eleValue.Addr() <span class="comment">//Elem</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> err := Unmarshal([]<span class="type">byte</span>(arr[i]), eleValue.Interface()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> s != <span class="string">&quot;null&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid json part: %s&quot;</span>, s)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Map:</span><br><span class="line">		<span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; s[<span class="built_in">len</span>(s)<span class="number">-1</span>] == <span class="string">&#x27;&#125;&#x27;</span> &#123;</span><br><span class="line">			arr := SplitJson(s[<span class="number">1</span> : <span class="built_in">len</span>(s)<span class="number">-1</span>]) <span class="comment">//去除前后的&#123;&#125;</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(arr) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				mapValue := reflect.ValueOf(v).Elem()                <span class="comment">//别忘了，v是指针</span></span><br><span class="line">				mapValue.Set(reflect.MakeMapWithSize(typ, <span class="built_in">len</span>(arr))) <span class="comment">//通过反射创建map</span></span><br><span class="line"></span><br><span class="line">				kType := typ.Key()  <span class="comment">//获取map的key的Type</span></span><br><span class="line">				vType := typ.Elem() <span class="comment">//获取map的value的Type</span></span><br><span class="line">				<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">					brr := strings.Split(arr[i], <span class="string">&quot;:&quot;</span>)</span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(brr) != <span class="number">2</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid json part: %s&quot;</span>, arr[i])</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					kValue := reflect.New(kType) <span class="comment">//根据Type创建指针型的Value</span></span><br><span class="line">					<span class="keyword">if</span> err := Unmarshal([]<span class="type">byte</span>(brr[<span class="number">0</span>]), kValue.Interface()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line">					vValue := reflect.New(vType) <span class="comment">//根据Type创建指针型的Value</span></span><br><span class="line">					<span class="keyword">if</span> err := Unmarshal([]<span class="type">byte</span>(brr[<span class="number">1</span>]), vValue.Interface()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line">					mapValue.SetMapIndex(kValue.Elem(), vValue.Elem()) <span class="comment">//往map里面赋值</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> s != <span class="string">&quot;null&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid json part: %s&quot;</span>, s)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> reflect.Struct:</span><br><span class="line">		<span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; s[<span class="built_in">len</span>(s)<span class="number">-1</span>] == <span class="string">&#x27;&#125;&#x27;</span> &#123;</span><br><span class="line">			arr := SplitJson(s[<span class="number">1</span> : <span class="built_in">len</span>(s)<span class="number">-1</span>])</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(arr) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				fieldCount := typ.NumField()</span><br><span class="line">				<span class="comment">//建立json tag到FieldName的映射关系</span></span><br><span class="line">				tag2Field := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, fieldCount)</span><br><span class="line">				<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; fieldCount; i++ &#123;</span><br><span class="line">					fieldType := typ.Field(i)</span><br><span class="line">					name := fieldType.Name</span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(fieldType.Tag.Get(<span class="string">&quot;json&quot;</span>)) &gt; <span class="number">0</span> &#123;</span><br><span class="line">						name = fieldType.Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">					&#125;</span><br><span class="line">					tag2Field[name] = fieldType.Name</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> _, ele := <span class="keyword">range</span> arr &#123;</span><br><span class="line">					brr := strings.SplitN(ele, <span class="string">&quot;:&quot;</span>, <span class="number">2</span>) <span class="comment">//json的value里可能存在嵌套，所以用:分隔时限定个数为2</span></span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(brr) == <span class="number">2</span> &#123;</span><br><span class="line">						tag := strings.Trim(brr[<span class="number">0</span>], <span class="string">&quot; &quot;</span>)</span><br><span class="line">						<span class="keyword">if</span> tag[<span class="number">0</span>] == <span class="string">&#x27;&quot;&#x27;</span> &amp;&amp; tag[<span class="built_in">len</span>(tag)<span class="number">-1</span>] == <span class="string">&#x27;&quot;&#x27;</span> &#123; <span class="comment">//json的key肯定是带&quot;&quot;的</span></span><br><span class="line">							tag = tag[<span class="number">1</span> : <span class="built_in">len</span>(tag)<span class="number">-1</span>]                        <span class="comment">//去除json key前后的&quot;&quot;</span></span><br><span class="line">							<span class="keyword">if</span> fieldName, exists := tag2Field[tag]; exists &#123; <span class="comment">//根据json key(即json tag)找到对应的FieldName</span></span><br><span class="line">								fieldValue := value.FieldByName(fieldName)</span><br><span class="line">								fieldType := fieldValue.Type()</span><br><span class="line">								<span class="keyword">if</span> fieldType.Kind() != reflect.Ptr &#123;</span><br><span class="line">									<span class="comment">//如果内嵌不是指针，则声明时已经用0值初始化了，此处只需要根据json改写它的值</span></span><br><span class="line">									fieldValue = fieldValue.Addr()                                            <span class="comment">//确保fieldValue指向指针类型，因为接下来要把fieldValue传给Unmarshal</span></span><br><span class="line">									<span class="keyword">if</span> err := Unmarshal([]<span class="type">byte</span>(brr[<span class="number">1</span>]), fieldValue.Interface()); err != <span class="literal">nil</span> &#123; <span class="comment">//递归调用Unmarshal，给fieldValue的底层数据赋值</span></span><br><span class="line">										<span class="keyword">return</span> err</span><br><span class="line">									&#125;</span><br><span class="line">								&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">									<span class="comment">//如果内嵌的是指针，则需要通过New()创建一个实例(申请内存空间)。不能给New()传指针型的Type，所以调一下Elem()</span></span><br><span class="line">									newValue := reflect.New(fieldType.Elem())                               <span class="comment">//newValue代表的是指针</span></span><br><span class="line">									<span class="keyword">if</span> err := Unmarshal([]<span class="type">byte</span>(brr[<span class="number">1</span>]), newValue.Interface()); err != <span class="literal">nil</span> &#123; <span class="comment">//递归调用Unmarshal，给fieldValue的底层数据赋值</span></span><br><span class="line">										<span class="keyword">return</span> err</span><br><span class="line">									&#125;</span><br><span class="line">									value.FieldByName(fieldName).Set(newValue) <span class="comment">//把newValue赋给value的Field</span></span><br><span class="line">								&#125;</span><br><span class="line"></span><br><span class="line">							&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">								fmt.Printf(<span class="string">&quot;字段%s找不到\n&quot;</span>, tag)</span><br><span class="line">							&#125;</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid json part: %s&quot;</span>, tag)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid json part: %s&quot;</span>, ele)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> s != <span class="string">&quot;null&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid json part: %s&quot;</span>, s)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;暂不支持类型:%s\n&quot;</span>, typ.Kind().String())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	json_str := <span class="string">`&#123;&quot;isbn&quot;:&quot;4243547567&quot;,&quot;Name&quot;:&quot;围城&quot;,&quot;price&quot;:34.799999,&quot;author&quot;:&#123;&quot;Name&quot;:&quot;钱钟书&quot;,&quot;Age&quot;:55,&quot;gender&quot;:1&#125;,&quot;kws&quot;:[&quot;爱情&quot;,&quot;民国&quot;,&quot;留学&quot;],&quot;Local&quot;:&#123;&quot;2&quot;:true,&quot;3&quot;:false&#125;&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> book Book <span class="comment">//必须先声明值类型，再通过&amp;给Unmarshal传一个指针参数。因为声明值类型会初始化为0值，而声明指针都没有创建底层的内存空间</span></span><br><span class="line">	<span class="keyword">if</span> err := Unmarshal([]<span class="type">byte</span>(json_str), &amp;book); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;err: %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;book: %+v\n&quot;</span>, book)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>book: {ISBN:4243547567 Name:围城 Price:34.8 Author:0xc000050440 Keywords:[爱情 民国 留学] Local:map[2:true 3:false]}</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://renm.cc">ren_mcc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://renm.cc/20221230/golang-20221230-golang%E5%8F%8D%E5%B0%84/">https://renm.cc/20221230/golang-20221230-golang%E5%8F%8D%E5%B0%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://renm.cc" target="_blank">ren_mccの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a></div><div class="post-share"><div class="social-share" data-image="/img/yuanshen/avatar/100012.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/20230103/golang-20230103-golang%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" title="golang加密算法"><img class="cover" src="/img/yuanshen/avatar/63d9f2d3572c11df029f74b27ec300d9f503c2c7.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">golang加密算法</div></div><div class="info-2"><div class="info-item-1">对称加密    加密过程的每一步都是可逆的。加密和解密用的是同一组密钥。异或是最简单的对称加密算法。 12345678910//XOR 异或运算，要求plain和key的长度相同func XOR(plain string, key []byte) string &#123;	bPlain := []byte(plain)	bCipher := make([]byte, len(key))	for i, k := range key &#123;		bCipher[i] = k ^ bPlain[i]	&#125;	cipher := string(bCipher)	return cipher&#125;   DES（Data Encryption Standard）数据加密标准，是目前最为流行的加密算法之一。对原始数据（明文）进行分组，每组64位，最后一组不足64位时按一定规则填充。每一组上单独施加DES算法。 DES子密钥生成   初始密钥64位，实际有效位56位，每隔7位有一个校验位。根据初始密钥生成16个48位的子密钥。      ...</div></div></div></a><a class="pagination-related" href="/20221230/golang-20221230-golang%E6%B3%9B%E5%9E%8B/" title="golang泛型"><img class="cover" src="/img/yuanshen/avatar/10002.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">golang泛型</div></div><div class="info-2"><div class="info-item-1">  在有泛型之前，同样的功能需要为不同的参数类型单独实现一个函数。 123456789func add4int(a, b int) int &#123;	return a + b&#125;func add4float32(a, b float32) float32 &#123;	return a + b&#125;func add4string(a, b string) string &#123;	return a + b&#125; 使用泛型 12345678type Addable interface&#123;type int, int8, int16, int32, int64,	uint, uint8, uint16, uint32, uint64, uintptr,	float32, float64, complex64, complex128,string&#125;func add[T Addable](a,b T)T&#123;	return...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/20221125/golang-20221125-golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="golang基础语法"><img class="cover" src="/img/yuanshen/avatar/b7fd5266d01609241b7224facde357f3e4cd34ed.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang基础语法</div></div><div class="info-2"><div class="info-item-1">标识符与关键字   go变量、常量、自定义类型、包、函数的命名方式必须遵循以下规则：  首字符可以是任意Unicode字符或下划线。 首字符之外的部分可以是Unicode字符、下划线或数字。 名字的长度无限制。   理论上名字里可以有汉字，甚至可以全是汉字，但实际中不要这么做。  Go语言关键字 1break  default  func  interface  select  case  defer  go  map  struct  chan  else  goto  package  switch  const  if  range  type  continue  for  import  return  fallthrough  var 常量 1true  false  iota  nil    数据类型 1int  int8  int16  int32  int64  uint  uint8  uint16  uint32  uint64  uintptr  float32  float64  complex128  complex64  bool  byte ...</div></div></div></a><a class="pagination-related" href="/20221202/golang-20221202-golang%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/" title="golang格式化输出"><img class="cover" src="/img/yuanshen/avatar/97400f365b0b47cf8533d9d0b4ebe150!400x400.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="info-item-2">golang格式化输出</div></div><div class="info-2"><div class="info-item-1">12345type WebSite struct &#123;	Name string&#125;var site = WebSite&#123;Name: &quot;ren123&quot;&#125; 普通占位符    占位符 说明 举例 输出     %v 相应值的默认格式 fmt.Printf(“site: %v\n”, site) site: {ren123}   %#v 响应值的Go语法表示 fmt.Printf(“site: %#v\n”, site) site: main.WebSite{Name:“ren123”}   %T 相应值的类型的Go语法表示 fmt.Printf(“site: %T\n”, site) site: main.WebSite   %% 字面上的百分号，并非值的占位符 fmt.Printf(“site: %%\n”, site) site: %    布尔占位符    占位符 说明 举例 输出     %t 单词true或false fmt.Printf(“b: %t\n”, b) b:...</div></div></div></a><a class="pagination-related" href="/20221125/golang-20221125-golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="golang数据类型"><img class="cover" src="/img/yuanshen/avatar/20210501094041_26fef.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang数据类型</div></div><div class="info-2"><div class="info-item-1">数据类型概览 基础数据类型    类型 长度(字节) 默认值 说明     bool 1 false    byte 1 0 uint8，取值范围[0,255]   rune 4 0 Unicode Code Point, int32   int, uint 4或8 0 32 或 64 位，取决于操作系统   int8, uint8 1 0 -128 ~ 127, 0 ~ 255   int16, uint16 2 0 -32768 ~ 32767, 0 ~ 65535   int32, uint32 4 0 -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名   int64, uint64 8 0    float32 4 0.0    float64 8 0.0    complex64 8     complex128 16     uintptr 4或8  以存储指针的 uint32 或 uint64...</div></div></div></a><a class="pagination-related" href="/20221125/golang-20221125-golang%E7%AE%80%E4%BB%8B/" title="golang简介"><img class="cover" src="/img/yuanshen/avatar/72e25032ecca4e50849950cec4efd821.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang简介</div></div><div class="info-2"><div class="info-item-1">Go语言发展历史 阵容豪华的创使人团队 Ken Thompson  1966年：加入了贝尔实验室，在参与 Multics （多路信息计算）开发期间，创造出了B语言，并用一个月的时间用B语言开发了全新的操作系统UNICS，后来改名为我们所熟悉的UNIX 操作系统。 1971年：和丹尼斯·利奇（Dennis Ritchie）一起共同发明了C语言。 1973年：和丹尼斯·利奇（Dennis Ritchie）使用C语言重写了UNIX，并安装于PDP-11的机器之上。 1983年：美国计算机协会将图灵奖授予汤普森。 2000年：离开贝尔实验室，已退休的汤普森成为了一名飞行员。 2006年：加入Google工作。 2007年：64岁的高龄，与Rob Pike和Robert Griesemer主导了Go语言的开发。  Rob Pike  Go语言项目总负责人。 贝尔实验室Unix团队成员，参与的项目包括Plan 9，Inferno操作系统和Limbo编程语言。 UTF-8字符集规范唯二的发明人之一（另一位是Ken...</div></div></div></a><a class="pagination-related" href="/20221203/golang-20221203-golang%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="golang流程控制"><img class="cover" src="/img/yuanshen/avatar/d1a20cf431adcbef7f6fa3648c4b4cd4a2cc9f62.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-03</div><div class="info-item-2">golang流程控制</div></div><div class="info-2"><div class="info-item-1">if 123if 5 &gt; 9 &#123;    fmt.Println(&quot;5&gt;9&quot;)&#125;  如果逻辑表达式成立，就会执行{}里的内容。 逻辑表达式不需要加()。 &quot;{&quot;必须紧跟在逻辑表达式后面，不能另起一行。  123if c, d, e := 5, 9, 2; c &lt; d &amp;&amp; (c &gt; e || c &gt; 3) &#123; //初始化多个局部变量。复杂的逻辑表达式    fmt.Println(&quot;fit&quot;)&#125;  逻辑表达中可以含有变量或常量。 if句子中允许包含1个(仅1个)分号，在分号前初始化一些局部变量(即只在if块内可见)。  if-else的用法 12345678910color := &quot;black&quot;if color == &quot;red&quot; &#123; //if只能有一个    fmt.Println(&quot;stop&quot;)&#125; else if color ==...</div></div></div></a><a class="pagination-related" href="/20221211/golang-20221209-golang%E5%8C%85%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96/" title="golang包与工程化"><img class="cover" src="/img/yuanshen/avatar/b7fd5266d01609241b7224facde357f3e4cd34ed.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-11</div><div class="info-item-2">golang包与工程化</div></div><div class="info-2"><div class="info-item-1">用go mod管理工程   初始化项目: 1go mod init $module_name $module_name和目录名可以不一样。上述命令会生成go.mod文件，该文件内容形如： 12345678module go-coursego 1.17require (    github.com/ethereum/go-ethereum v1.10.8    github.com/gin-gonic/gin v1.7.4)   Go依次从当前项目、GOROOT、GOPATH下寻找依赖包。  从当前go文件所在的目录逐级向上查找go.mod文件（假设go.mod位于目录mode_path下），里面定义了module_name，则引入包的路径为&quot;module_name/包相对于mode_path的路径&quot;。 go标准库提供的包在GOROOT/src下。 第三方依赖包在GOPATH/pkg/mod下。    从go1.7开始，go get只负责下载第三方依赖包，并把它加到go.mod文件里，由go install负责安装二进制文件。  go get...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">反射介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">反射的基础数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84API"><span class="toc-number">3.</span> <span class="toc-text">反射API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reflect-Type"><span class="toc-number">3.1.</span> <span class="toc-text">reflect.Type</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0Type"><span class="toc-number">3.1.1.</span> <span class="toc-text">如何得到Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88Type%E8%BD%AC%E4%B8%BA%E9%9D%9E%E6%8C%87%E9%92%88Type"><span class="toc-number">3.1.2.</span> <span class="toc-text">指针Type转为非指针Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96struct%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">3.1.3.</span> <span class="toc-text">获取struct成员变量的信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96struct%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">3.1.4.</span> <span class="toc-text">获取struct成员方法的信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">3.1.5.</span> <span class="toc-text">获取函数的信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%9F%90%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.6.</span> <span class="toc-text">判断类型是否实现了某接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reflect-Value"><span class="toc-number">3.2.</span> <span class="toc-text">reflect.Value</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%8E%B7%E5%BE%97Value"><span class="toc-number">3.2.1.</span> <span class="toc-text">如果获得Value</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Value%E8%BD%AC%E4%B8%BAType"><span class="toc-number">3.2.2.</span> <span class="toc-text">Value转为Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88Value%E5%92%8C%E9%9D%9E%E6%8C%87%E9%92%88Value%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.3.</span> <span class="toc-text">指针Value和非指针Value互相转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%97%E5%88%B0Value%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.4.</span> <span class="toc-text">得到Value对应的原始数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BAValue%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">3.2.5.</span> <span class="toc-text">空Value的判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Value%E4%BF%AE%E6%94%B9%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%80%BC"><span class="toc-number">3.2.6.</span> <span class="toc-text">通过Value修改原始数据的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Value%E4%BF%AE%E6%94%B9Slice"><span class="toc-number">3.2.7.</span> <span class="toc-text">通过Value修改Slice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9map"><span class="toc-number">3.2.8.</span> <span class="toc-text">修改map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.9.</span> <span class="toc-text">调用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.10.</span> <span class="toc-text">调用成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAstruct"><span class="toc-number">3.3.1.</span> <span class="toc-text">创建struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAslice"><span class="toc-number">3.3.2.</span> <span class="toc-text">创建slice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAmap"><span class="toc-number">3.3.3.</span> <span class="toc-text">创建map</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E8%A1%8C%E5%AE%9E%E7%8E%B0json%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">自行实现json序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-number">5.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96json"><span class="toc-number">5.1.</span> <span class="toc-text">序列化json</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96json"><span class="toc-number">5.2.</span> <span class="toc-text">反序列化json</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By ren_mcc</div><div class="footer_custom_text"><a rel="noopener external nofollow noreferrer noopener" target="_blank" href="https://beian.miit.gov.cn/"> <img class="icp-icon entered loading" alt="ICP" src="/img/icp.png" data-ll-status><span>京ICP备2022001205号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: [''],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'b53fa8f1e78aed26ec8c8a7b33fb444a'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><div class="aplayer no-destroy" data-id="7211977673" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="list" data-preload="none" data-autoplay="false" muted></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/docker/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 docker (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/docker-compose/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 docker-compose (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/containerd/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 containerd (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/kubernetes/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 kubernetes (27)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/python/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 python (37)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/golang/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 golang (38)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 redis (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/kafka/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 kafka (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://renm.cc/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><!-- hexo injector body_end end --></body></html>