<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>GRPC | ren_mccの博客</title><meta name="author" content="ren_mcc"><meta name="copyright" content="ren_mcc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="gRPC是Google公司基于Protobuf开发的跨语言的开源RPC框架。gRPC基于HTTP&#x2F;2协议设计，可以基于一个HTTP&#x2F;2链接提供多个服务，对于移动设备更加友好。 GRPC技术栈   数据交互格式: protobuf 通信方式: 最底层为TCP或Unix Socket协议，在此之上是HTTP&#x2F;2协议的实现 核心库: 在HTTP&#x2F;2协议之上又构建了针对Go语言的gRPC核心库 Stub">
<meta property="og:type" content="article">
<meta property="og:title" content="GRPC">
<meta property="og:url" content="https://renm.cc/20230301/golang-20230301-GRPC/index.html">
<meta property="og:site_name" content="ren_mccの博客">
<meta property="og:description" content="gRPC是Google公司基于Protobuf开发的跨语言的开源RPC框架。gRPC基于HTTP&#x2F;2协议设计，可以基于一个HTTP&#x2F;2链接提供多个服务，对于移动设备更加友好。 GRPC技术栈   数据交互格式: protobuf 通信方式: 最底层为TCP或Unix Socket协议，在此之上是HTTP&#x2F;2协议的实现 核心库: 在HTTP&#x2F;2协议之上又构建了针对Go语言的gRPC核心库 Stub">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://renm.cc/img/yuanshen/avatar/1f178a82b9014a904ee6e31f2649141bb21bee04.jpeg">
<meta property="article:published_time" content="2023-02-28T16:14:12.000Z">
<meta property="article:modified_time" content="2023-06-28T13:47:21.774Z">
<meta property="article:author" content="ren_mcc">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://renm.cc/img/yuanshen/avatar/1f178a82b9014a904ee6e31f2649141bb21bee04.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://renm.cc/20230301/golang-20230301-GRPC/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GRPC',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><script src="/js/jquery.min.js"></script><link rel="stylesheet" href="/js/function.min.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="/js/custom.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg" style="background-image: url(/img/backgroud7.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar2.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">148</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/yuanshen/avatar/1f178a82b9014a904ee6e31f2649141bb21bee04.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ren_mccの博客</span></a><a class="nav-page-title" href="/"><span class="site-name">GRPC</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">GRPC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-28T16:14:12.000Z" title="发表于 2023-03-01 00:14:12">2023-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-28T13:47:21.774Z" title="更新于 2023-06-28 21:47:21">2023-06-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/golang/">golang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2023-06-28 21:47:21&quot;}" hidden></div><p><img src="./grpc.png" alt="avatar"></p>
<p>gRPC是Google公司基于Protobuf开发的跨语言的开源RPC框架。gRPC基于HTTP/2协议设计，可以基于一个HTTP/2链接提供多个服务，对于移动设备更加友好。</p>
<h2 id="GRPC技术栈">GRPC技术栈</h2>
<p><img src="./grpc-go-stack.png" alt="avatar"></p>
<ul>
<li>数据交互格式: protobuf</li>
<li>通信方式: 最底层为TCP或Unix Socket协议，在此之上是HTTP/2协议的实现</li>
<li>核心库: 在HTTP/2协议之上又构建了针对Go语言的gRPC核心库</li>
<li>Stub: 应用程序通过gRPC插件生产的Stub代码和gRPC核心库通信，也可以直接和gRPC核心库通信</li>
</ul>
<p>gRPC采用protobuf描述 接口和数据, 我们可以把他理解为: protobuf ON HTTP2 的一种RPC</p>
<h2 id="Hello-gRPC">Hello gRPC</h2>
<p>下面我们讲演示一个基础的gRPC服务.</p>
<h3 id="protobuf-grpc插件">protobuf grpc插件</h3>
<p>protobuf 不仅可以定义交互的数据结构(message), 还可以定义交互的接口:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service HelloService &#123;</span><br><span class="line">    rpc Hello (String) returns (String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Protobuf的角度看，gRPC只不过是一个针对service接口生成代码的生成器。因此我们需要提前安装grpc的代码生成插件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># protoc-gen-<span class="keyword">go</span> 插件之前已经安装</span><br><span class="line"># <span class="keyword">go</span> install google.golang.org/protobuf/cmd/protoc-gen-<span class="keyword">go</span>@latest</span><br><span class="line"></span><br><span class="line"># 安装protoc-gen-<span class="keyword">go</span>-grpc插件</span><br><span class="line"><span class="keyword">go</span> install google.golang.org/grpc/cmd/protoc-gen-<span class="keyword">go</span>-grpc@latest</span><br></pre></td></tr></table></figure>
<h3 id="生成代码">生成代码</h3>
<p>然后基于protoc-gen-go-grpc来生产我们的grpc代码, 我们把之前的rpc 修改为GRPC</p>
<p>我们看看protobuf 定义接口的语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service &lt;service_name&gt; &#123;</span><br><span class="line">    rpc &lt;function_name&gt; (&lt;request&gt;) returns (&lt;response&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>service: 用于申明这是个服务的接口</li>
<li>service_name: 服务的名称,接口名称</li>
<li>function_name: 函数的名称</li>
<li>request: 函数参数， 必须的</li>
<li>response: 函数返回， 必须的, 不能没有</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package hello;</span><br><span class="line">option go_package=&quot;test_rpc/pbrpc/service&quot;;</span><br><span class="line"></span><br><span class="line">// The HelloService service definition.</span><br><span class="line">service HelloService &#123;</span><br><span class="line">    rpc Hello (Request) returns (Response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Request &#123;</span><br><span class="line">    string value = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Response &#123;</span><br><span class="line">    string value = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们生产代码, 同时制定gprc插件对应参数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=./grpc/pb --go_out=./grpc/pb  --go_opt=module=<span class="string">&quot;test-grpc/grpc/pb&quot;</span> ./grpc/pb/hello.proto</span><br></pre></td></tr></table></figure>
<h2 id="gRPC服务端">gRPC服务端</h2>
<p>基于服务端的HelloServiceServer接口可以重新实现HelloService服务</p>
<p>首先我们构建一个服务实体，实现GRPC定义的接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;test-grpc/grpc/pb&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ pb.HelloServiceServer = <span class="built_in">new</span>(HelloServiceServer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnimplementedHelloServiceServer must be embedded to have forward compatible implementations.</span></span><br><span class="line"><span class="keyword">type</span> HelloServiceServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	*pb.UnimplementedHelloServiceServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *HelloServiceServer)</span></span> Hello(ctx context.Context, req *pb.Request) (*pb.Response, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.Response&#123;Value: fmt.Sprintf(<span class="string">&quot;Hello %s&quot;</span>, req.Value)&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 首先是通过grpc.NewServer()构造一个gRPC服务对象</span></span><br><span class="line">	grpcServer := grpc.NewServer()</span><br><span class="line">	<span class="comment">// 然后通过gRPC插件生成的RegisterHelloServiceServer函数注册我们实现的HelloServiceImpl服务</span></span><br><span class="line">	pb.RegisterHelloServiceServer(grpcServer, <span class="built_in">new</span>(HelloServiceServer))</span><br><span class="line"></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 然后通过grpcServer.Serve(lis)在一个监听端口上提供gRPC服务</span></span><br><span class="line">	grpcServer.Serve(lis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gRPC客户端">gRPC客户端</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;test-grpc/grpc/pb&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// grpc.Dial负责和gRPC服务建立链接</span></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost:1234&quot;</span>, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// NewHelloServiceClient函数基于已经建立的链接构造HelloServiceClient对象,</span></span><br><span class="line">	<span class="comment">// 返回的client其实是一个HelloServiceClient接口对象</span></span><br><span class="line">	client := pb.NewHelloServiceClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过接口定义的方法就可以调用服务端对应的gRPC服务提供的方法</span></span><br><span class="line">	req := &amp;pb.Request&#123;Value: <span class="string">&quot;张三&quot;</span>&#125;</span><br><span class="line">	reply, err := client.Hello(context.Background(), req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(reply.GetValue())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="gRPC流">gRPC流</h2>
<p>RPC是远程函数调用，因此每次调用的函数参数和返回值不能太大，否则将严重影响每次调用的响应时间。因此传统的RPC方法调用对于上传和下载较大数据量场景并不适合。为此，gRPC框架针对服务器端和客户端分别提供了流特性</p>
<p>服务端或客户端的单向流是双向流的特例，我们在HelloService增加一个支持双向流的Channel方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// The HelloService service definition.</span><br><span class="line">service HelloService &#123;</span><br><span class="line">    rpc Hello (Request) returns (Response) &#123;&#125;</span><br><span class="line">    rpc Channel (stream Request) returns (stream Response) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键字stream指定启用流特性，参数部分是接收客户端参数的流，返回值是返回给客户端的流。</p>
<h3 id="生成Streaming-RPC">生成Streaming RPC</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=./grpc/pb --go-grpc_out=./grpc/pb --go-grpc_opt=module=<span class="string">&quot;test-grpc/grpc/pb&quot;</span> ./grpc/pb/hello.proto</span><br></pre></td></tr></table></figure>
<p>我们看看接口的变化:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端的Channel方法返回一个HelloService_ChannelClient类型的返回值，可以用于和服务端进行双向通信</span></span><br><span class="line"><span class="comment">// HelloServiceClient is the client API for HelloService service.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.</span></span><br><span class="line"><span class="keyword">type</span> HelloServiceClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, <span class="type">error</span>)</span><br><span class="line">	Channel(ctx context.Context, opts ...grpc.CallOption) (HelloService_ChannelClient, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在服务端的Channel方法参数是一个新的HelloService_ChannelServer类型的参数，可以用于和客户端双向通信</span></span><br><span class="line"><span class="comment">// HelloServiceServer is the server API for HelloService service.</span></span><br><span class="line"><span class="comment">// All implementations must embed UnimplementedHelloServiceServer</span></span><br><span class="line"><span class="comment">// for forward compatibility</span></span><br><span class="line"><span class="keyword">type</span> HelloServiceServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello(context.Context, *Request) (*Response, <span class="type">error</span>)</span><br><span class="line">	Channel(HelloService_ChannelServer) <span class="type">error</span></span><br><span class="line">	mustEmbedUnimplementedHelloServiceServer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HelloService_ChannelClient 和 HelloService_ChannelServer 接口定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request  -----&gt; </span></span><br><span class="line"><span class="comment">// Response &lt;----</span></span><br><span class="line"><span class="keyword">type</span> HelloService_ChannelClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*Request) <span class="type">error</span></span><br><span class="line">	Recv() (*Response, <span class="type">error</span>)</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request &lt;----</span></span><br><span class="line"><span class="comment">// Reponse ----&gt;</span></span><br><span class="line"><span class="keyword">type</span> HelloService_ChannelServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*Response) <span class="type">error</span></span><br><span class="line">	Recv() (*Request, <span class="type">error</span>)</span><br><span class="line">	grpc.ServerStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现服务端和客户端的流辅助接口均定义了Send和Recv方法用于流数据的双向通信</p>
<h3 id="服务端-2">服务端</h3>
<p>server端逻辑:</p>
<ul>
<li>接收一个Request</li>
<li>响应一个Response</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloService)</span></span> Channel(stream service.HelloService_ChannelServer) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 服务端在循环中接收客户端发来的数据</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 接收一个请求</span></span><br><span class="line">		args, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 如果遇到io.EOF表示客户端流被关闭</span></span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 响应一个请求</span></span><br><span class="line">		<span class="comment">// 生成返回的数据通过流发送给客户端</span></span><br><span class="line">		resp := &amp;service.Response&#123;Value: <span class="string">&quot;hello:&quot;</span> + args.GetValue()&#125;</span><br><span class="line">		err = stream.Send(resp)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 服务端发送异常, 函数退出, 服务端流关闭</span></span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双向流数据的发送和接收都是完全独立的行为。</p>
<p>需要注意的是，发送和接收的操作并不需要一一对应，用户可以根据真实场景进行组织代码</p>
<h3 id="客户端-2">客户端</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;test-rpc/grpc/service&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost:1234&quot;</span>, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	client := service.NewHelloServiceClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 客户端需要先调用Channel方法获取返回的流对象</span></span><br><span class="line">	stream, err := client.Channel(context.Background())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在客户端我们将发送和接收操作放到两个独立的Goroutine。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先是向服务端发送数据</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := stream.Send(&amp;service.Request&#123;Value: <span class="string">&quot;hi&quot;</span>&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatal(err)</span><br><span class="line">			&#125;</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 然后在循环中接收服务端返回的数据</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		reply, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(reply.GetValue())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gRPC认证">gRPC认证</h2>
<p>前面我们的grpc服务 在无任何保护机制下 都可以被任何人调用, 这是很危险的, 因此我们需要为grpc 添加认证的功能</p>
<p>我们在上面的流程中可以得知Grpc有2种模式:</p>
<ul>
<li>Request Response模式</li>
<li>Stream 模式</li>
</ul>
<p>在grpc的认证体系中, 着2种认证是独立开的</p>
<h3 id="Request-Response认证">Request Response认证</h3>
<p>我们先来看看 grpc框架给我们预留的 拦截器钩子:</p>
<p><img src="./grpc-unary.png" alt="avatar"></p>
<h4 id="原理">原理</h4>
<p><img src="./grpc-server-inter.png" alt="avatar"></p>
<ul>
<li>ctx 请求上下文</li>
<li>req rpc请求数据</li>
<li>info 服务端相关数据, 不用理解这个</li>
<li>handler 处理请求的handler, 相对于next()</li>
<li>resp rpc响应</li>
<li>err rpc 错误</li>
</ul>
<p>gprc 基于HTTP2通讯, grpc的拦截器的作用原理和 http的中间件是一样的:</p>
<p><img src="./http-middle.png" alt="avatar"></p>
<h4 id="编写中间件">编写中间件</h4>
<p>基于此原理，我们来编写一个 Request Response模式下的中间件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ClientHeaderKey = <span class="string">&quot;client-id&quot;</span></span><br><span class="line">	ClientSecretKey = <span class="string">&quot;client-secret&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GrpcAuthUnaryServerInterceptor returns a new unary server interceptor for auth.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GrpcAuthUnaryServerInterceptor</span><span class="params">()</span></span> grpc.UnaryServerInterceptor &#123;</span><br><span class="line">	<span class="keyword">return</span> newGrpcAuther().Auth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newGrpcAuther</span><span class="params">()</span></span> *grpcAuther &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;grpcAuther&#123;</span><br><span class="line">		log: zap.L().Named(<span class="string">&quot;Grpc Auther&quot;</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// internal todo</span></span><br><span class="line"><span class="keyword">type</span> grpcAuther <span class="keyword">struct</span> &#123;</span><br><span class="line">	log logger.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *grpcAuther)</span></span> Auth(</span><br><span class="line">	ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;,</span><br><span class="line">	info *grpc.UnaryServerInfo,</span><br><span class="line">	handler grpc.UnaryHandler,</span><br><span class="line">) (resp <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 重上下文中获取认证信息</span></span><br><span class="line">	md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;ctx is not an grpc incoming context&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;gprc header info: &quot;</span>, md)</span><br><span class="line"></span><br><span class="line">	clientId, clientSecret := a.GetClientCredentialsFromMeta(md)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 校验调用的客户端凭证是否有效</span></span><br><span class="line">	<span class="keyword">if</span> err := a.validateServiceCredential(clientId, clientSecret); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp, err = handler(ctx, req)</span><br><span class="line">	<span class="keyword">return</span> resp, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *grpcAuther)</span></span> GetClientCredentialsFromMeta(md metadata.MD) (</span><br><span class="line">	clientId, clientSecret <span class="type">string</span>) &#123;</span><br><span class="line">	cids := md.Get(ClientHeaderKey)</span><br><span class="line">	sids := md.Get(ClientSecretKey)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(cids) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		clientId = cids[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(sids) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		clientSecret = sids[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *grpcAuther)</span></span> validateServiceCredential(clientId, clientSecret <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> clientId == <span class="string">&quot;&quot;</span> &amp;&amp; clientSecret == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> status.Errorf(codes.Unauthenticated, <span class="string">&quot;client_id or client_secret is \&quot;\&quot;&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !(clientId == <span class="string">&quot;admin&quot;</span> &amp;&amp; clientSecret == <span class="string">&quot;123456&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> status.Errorf(codes.Unauthenticated, <span class="string">&quot;client_id or client_secret invalidate&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Server添加认证">Server添加认证</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是通过grpc.NewServer()构造一个gRPC服务对象</span></span><br><span class="line">grpcServer := grpc.NewServer(</span><br><span class="line">	<span class="comment">// 添加认证中间件, 如果有多个中间件需要添加 使用ChainUnaryInterceptor</span></span><br><span class="line">	grpc.UnaryInterceptor(auther.GrpcAuthUnaryServerInterceptor()),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="Client携带认证-基础">Client携带认证(基础)</h4>
<p>客户端每次发送RPC时都需要携带上 调用凭证, 也就是服务端认证是需要的:</p>
<ul>
<li>client_id</li>
<li>client_secret</li>
</ul>
<p>那客户端怎么把凭证传递给服务端端喃? 对照 http1.1 的认证逻辑(通过Header来传递), grpc也提供了类似的机制: metadata,</p>
<p>我们可以把凭证放到metadata中, 传递给服务端, 然后服务端从中取出, 进行校验。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// grpc.Dial负责和gRPC服务建立链接</span></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost:1234&quot;</span>, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// NewHelloServiceClient函数基于已经建立的链接构造HelloServiceClient对象,</span></span><br><span class="line">	<span class="comment">// 返回的client其实是一个HelloServiceClient接口对象</span></span><br><span class="line">	client := pb.NewHelloServiceClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加认证信息</span></span><br><span class="line">	crendential := metadata.MD&#123;server.ClientHeaderKey: []<span class="type">string</span>&#123;<span class="string">&quot;admin&quot;</span>&#125;, server.ClientSecretKey: []<span class="type">string</span>&#123;<span class="string">&quot;1234567&quot;</span>&#125;&#125;</span><br><span class="line">	ctx := metadata.NewOutgoingContext(context.Background(), crendential)</span><br><span class="line">	<span class="comment">// 通过接口定义的方法就可以调用服务端对应的gRPC服务提供的方法</span></span><br><span class="line">	<span class="comment">// 每次带上凭证信息</span></span><br><span class="line">	reply, err := client.Hello(ctx, &amp;pb.Request&#123;Value: <span class="string">&quot;张三&quot;</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(reply.GetValue())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Client携带认证-改进">Client携带认证(改进)</h4>
<p>如果我们每次都 怎么传递, 是不是有点蠢, 我们为啥不封装一个类似 客户端中间件的函数, 每次发送的时候调用下喃?</p>
<p>你的这种想法 作者也知道, 因此他为我们设计了一种机制: WithPerRPCCredentials, 每次调用的时候, 都从获取凭证 注入到metadata中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithPerRPCCredentials returns a DialOption which sets credentials and places</span></span><br><span class="line"><span class="comment">// auth state on each outbound RPC.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithPerRPCCredentials</span><span class="params">(creds credentials.PerRPCCredentials)</span></span> DialOption &#123;</span><br><span class="line">	<span class="keyword">return</span> newFuncDialOption(<span class="function"><span class="keyword">func</span><span class="params">(o *dialOptions)</span></span> &#123;</span><br><span class="line">		o.copts.PerRPCCredentials = <span class="built_in">append</span>(o.copts.PerRPCCredentials, creds)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 PerRPCCredentials 是一个接口:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PerRPCCredentials defines the common interface for the credentials which need to</span></span><br><span class="line"><span class="comment">// attach security information to every RPC (e.g., oauth2).</span></span><br><span class="line"><span class="keyword">type</span> PerRPCCredentials <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// GetRequestMetadata gets the current request metadata, refreshing</span></span><br><span class="line">	<span class="comment">// tokens if required. This should be called by the transport layer on</span></span><br><span class="line">	<span class="comment">// each request, and the data should be populated in headers or other</span></span><br><span class="line">	<span class="comment">// context. If a status code is returned, it will be used as the status</span></span><br><span class="line">	<span class="comment">// for the RPC. uri is the URI of the entry point for the request.</span></span><br><span class="line">	<span class="comment">// When supported by the underlying implementation, ctx can be used for</span></span><br><span class="line">	<span class="comment">// timeout and cancellation. Additionally, RequestInfo data will be</span></span><br><span class="line">	<span class="comment">// available via ctx to this call.</span></span><br><span class="line">	<span class="comment">// TODO(zhaoq): Define the set of the qualified keys instead of leaving</span></span><br><span class="line">	<span class="comment">// it as an arbitrary string.</span></span><br><span class="line">	GetRequestMetadata(ctx context.Context, uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// RequireTransportSecurity indicates whether the credentials requires</span></span><br><span class="line">	<span class="comment">// transport security.</span></span><br><span class="line">	RequireTransportSecurity() <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那接下来我们实现该接口, 就实现了我们的客户端认证的携带机制:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> auther</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClientAuthentication</span><span class="params">(clientId, clientSecret <span class="type">string</span>)</span></span> *Authentication &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Authentication&#123;</span><br><span class="line">		clientID:     clientId,</span><br><span class="line">		clientSecret: clientSecret,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Authentication todo</span></span><br><span class="line"><span class="keyword">type</span> Authentication <span class="keyword">struct</span> &#123;</span><br><span class="line">	clientID     <span class="type">string</span></span><br><span class="line">	clientSecret <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithClientCredentials todo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Authentication)</span></span> WithClientCredentials(clientID, clientSecret <span class="type">string</span>) &#123;</span><br><span class="line">	a.clientID = clientID</span><br><span class="line">	a.clientSecret = clientSecret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetRequestMetadata todo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Authentication)</span></span> GetRequestMetadata(context.Context, ...<span class="type">string</span>) (</span><br><span class="line">	<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>,</span><br><span class="line">) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;client-id&quot;</span>:     a.clientID,</span><br><span class="line">		<span class="string">&quot;client-secret&quot;</span>: a.clientSecret,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequireTransportSecurity todo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Authentication)</span></span> RequireTransportSecurity() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们在建立grpc的连接的时候，就传递我们的Credential, 就实现了客户端携带凭证</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// grpc.Dial负责和gRPC服务建立链接</span></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost:1234&quot;</span>, grpc.WithInsecure(), grpc.WithPerRPCCredentials(auther.NewClientAuthentication(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span>)))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// NewHelloServiceClient函数基于已经建立的链接构造HelloServiceClient对象,</span></span><br><span class="line">	<span class="comment">// 返回的client其实是一个HelloServiceClient接口对象</span></span><br><span class="line">	client := pb.NewHelloServiceClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加认证信息</span></span><br><span class="line">	<span class="comment">// crendential := metadata.MD&#123;auther.ClientHeaderKey: []string&#123;&quot;admin&quot;&#125;, auther.ClientSecretKey: []string&#123;&quot;123456&quot;&#125;&#125;</span></span><br><span class="line">	<span class="comment">// ctx := metadata.NewOutgoingContext(context.Background(), crendential)</span></span><br><span class="line"></span><br><span class="line">	ctx := metadata.NewOutgoingContext(context.Background(), metadata.Pairs())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过接口定义的方法就可以调用服务端对应的gRPC服务提供的方法</span></span><br><span class="line">	<span class="comment">// 每次带上凭证信息</span></span><br><span class="line">	reply, err := client.Hello(ctx, &amp;pb.Request&#123;Value: <span class="string">&quot;张三&quot;</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(reply.GetValue())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 客户端需要先调用Channel方法获取返回的流对象</span></span><br><span class="line">	stream, err := client.Channel(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在客户端我们将发送和接收操作放到两个独立的Goroutine。</span></span><br><span class="line">	<span class="comment">// 首先是向服务端发送数据</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := stream.Send(&amp;pb.Request&#123;Value: <span class="string">&quot;hi&quot;</span>&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatal(err)</span><br><span class="line">			&#125;</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 然后在循环中接收服务端返回的数据</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		reply, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(reply.GetValue())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Stream-认证">Stream 认证</h3>
<p>stream认证 不同于 request reponse认证模式, 因为客户端和服务端是建立的长连接, 就行TCP一样, 因此一般我们只需要在 连接建立开始做下认证, 传递过程中 我们无需对每次交互做认证。</p>
<h4 id="原理-2">原理</h4>
<p>和http中间件一样, stream模式下，grpc也提供了一个钩子:</p>
<p><img src="./grpc-stream-unr.png" alt="avatar"></p>
<ul>
<li>srv service信息</li>
<li>ss Server 了数据流</li>
<li>info 服务端相关数据, 不用理解这个</li>
<li>handler 处理请求的handler, 相当于next()</li>
<li>err rpc 错误</li>
</ul>
<p>我们的任务就是实现一个这样的函数, 在函数中添加认证逻辑</p>
<h4 id="编写中间件-2">编写中间件</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *grpcAuther)</span></span> streamAuth(srv <span class="keyword">interface</span>&#123;&#125;, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 从上下文中获取认证信息</span></span><br><span class="line">	md, ok := metadata.FromIncomingContext(ss.Context())</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;ctx is not an grpc incoming context&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;gprc header info: &quot;</span>, md)</span><br><span class="line"></span><br><span class="line">	clientId, clientSecret := a.getClientCredentialsFromMeta(md)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 校验调用的客户端凭证是否有效</span></span><br><span class="line">	<span class="keyword">if</span> err := a.validateServiceCredential(clientId, clientSecret); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> handler(srv, ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Server添加认证-2">Server添加认证</h4>
<p>然后我们补充上 stream的认证中间件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是通过grpc.NewServer()构造一个gRPC服务对象</span></span><br><span class="line">grpcServer := grpc.NewServer(</span><br><span class="line">	<span class="comment">// 添加认证中间件, 如果有多个中间件需要添加 使用ChainUnaryInterceptor</span></span><br><span class="line">	grpc.UnaryInterceptor(auther.GrpcAuthUnaryServerInterceptor()),</span><br><span class="line">	<span class="comment">// 添加stream API的拦截器</span></span><br><span class="line">	grpc.StreamInterceptor(auther.GrpcAuthStreamServerInterceptor()),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="客户端携带认证">客户端携带认证</h4>
<p>客户端提供凭证的逻辑和 Request Reponse模式一样</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://renm.cc">ren_mcc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://renm.cc/20230301/golang-20230301-GRPC/">https://renm.cc/20230301/golang-20230301-GRPC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://renm.cc" target="_blank">ren_mccの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a></div><div class="post-share"><div class="social-share" data-image="/img/yuanshen/avatar/1f178a82b9014a904ee6e31f2649141bb21bee04.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/20230326/vue-20230326-vue%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" title="vue基础入门"><img class="cover" src="/img/yuanshen/avatar/8f16e2511e864f01955f9659b351ee21!400x400.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">vue基础入门</div></div><div class="info-2"><div class="info-item-1">1. vue介绍 1.1 什么是vue 官方给出的概念：Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的前端框架。  构建用户界面  用vue往html页面中填充数据，非常的方便   框架  框架是一套现成的解决方案，程序员只能遵守框架的规范，去编写自己的业务功能 要学习vue，就是在学习vue框架中规定的用法 vue的指令、组件（是对UI结构的复用）、路由、Vuex、vue组件库 只有把上面罗列的内容掌握以后，才有才发vue项目的能力     1.2 vue的特性 vue 框架的特性，主要体现在如下两方面： ① 数据驱动视图 ② 双向数据绑定 1.2.1 数据驱动视图 在使用了 vue 的页面中，vue 会监听数据的变化，从而自动重新渲染页面的结构。示意图如下：  1.2.2 双向数据绑定 在填写表单时，双向数据绑定可以辅助开发者在不操作 DOM 的前提下，自动把用户填写的内容同步到数据源 中。示意图如下：  1.3 MVVM MVVM 是 vue 实现数据驱动视图和双向数据绑定的核心原理。MVVM 指的是 Model、View 和...</div></div></div></a><a class="pagination-related" href="/20230227/golang-20230227-Protobuf%E7%BC%96%E8%A7%A3%E7%A0%81/" title="Protobuf编解码"><img class="cover" src="/img/yuanshen/avatar/a044ad345982b2b7baab40edbd93e6e676099bae.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Protobuf编解码</div></div><div class="info-2"><div class="info-item-1"> Protobuf是Protocol Buffers的简称，它是Google公司开发的一种数据描述语言，并于2008年对外开源。Protobuf刚开源时的定位类似于XML、JSON等数据描述语言，通过附带工具生成代码并实现将结构化数据序列化的功能。但是我们更关注的是Protobuf作为接口规范的描述语言，可以作为设计安全的跨语言PRC接口的基础工具 官网 为什么选择Protobuf 一般而言我们需要一种编解码工具会参考:  编解码效率 高压缩比 多语言支持  其中压缩与效率 最被关注的点:  使用流程 首先需要定义我们的数据，通过编译器，来生成不同语言的代码  之前我们的RPC要么使用的Gob, 要么使用的json, 接下来我们将使用probuf 首先创建hello.proto文件，其中包装HelloService服务中用到的字符串类型 12345678syntax = &quot;proto3&quot;;package hello;option go_package=&quot;pbrpc/pb&quot;;message String &#123;    string...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/20221125/golang-20221125-golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="golang基础语法"><img class="cover" src="/img/yuanshen/avatar/b7fd5266d01609241b7224facde357f3e4cd34ed.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang基础语法</div></div><div class="info-2"><div class="info-item-1">标识符与关键字   go变量、常量、自定义类型、包、函数的命名方式必须遵循以下规则：  首字符可以是任意Unicode字符或下划线。 首字符之外的部分可以是Unicode字符、下划线或数字。 名字的长度无限制。   理论上名字里可以有汉字，甚至可以全是汉字，但实际中不要这么做。  Go语言关键字 1break  default  func  interface  select  case  defer  go  map  struct  chan  else  goto  package  switch  const  if  range  type  continue  for  import  return  fallthrough  var 常量 1true  false  iota  nil    数据类型 1int  int8  int16  int32  int64  uint  uint8  uint16  uint32  uint64  uintptr  float32  float64  complex128  complex64  bool  byte ...</div></div></div></a><a class="pagination-related" href="/20221202/golang-20221202-golang%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/" title="golang格式化输出"><img class="cover" src="/img/yuanshen/avatar/97400f365b0b47cf8533d9d0b4ebe150!400x400.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="info-item-2">golang格式化输出</div></div><div class="info-2"><div class="info-item-1">12345type WebSite struct &#123;	Name string&#125;var site = WebSite&#123;Name: &quot;ren123&quot;&#125; 普通占位符    占位符 说明 举例 输出     %v 相应值的默认格式 fmt.Printf(“site: %v\n”, site) site: {ren123}   %#v 响应值的Go语法表示 fmt.Printf(“site: %#v\n”, site) site: main.WebSite{Name:“ren123”}   %T 相应值的类型的Go语法表示 fmt.Printf(“site: %T\n”, site) site: main.WebSite   %% 字面上的百分号，并非值的占位符 fmt.Printf(“site: %%\n”, site) site: %    布尔占位符    占位符 说明 举例 输出     %t 单词true或false fmt.Printf(“b: %t\n”, b) b:...</div></div></div></a><a class="pagination-related" href="/20221125/golang-20221125-golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="golang数据类型"><img class="cover" src="/img/yuanshen/avatar/20210501094041_26fef.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang数据类型</div></div><div class="info-2"><div class="info-item-1">数据类型概览 基础数据类型    类型 长度(字节) 默认值 说明     bool 1 false    byte 1 0 uint8，取值范围[0,255]   rune 4 0 Unicode Code Point, int32   int, uint 4或8 0 32 或 64 位，取决于操作系统   int8, uint8 1 0 -128 ~ 127, 0 ~ 255   int16, uint16 2 0 -32768 ~ 32767, 0 ~ 65535   int32, uint32 4 0 -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名   int64, uint64 8 0    float32 4 0.0    float64 8 0.0    complex64 8     complex128 16     uintptr 4或8  以存储指针的 uint32 或 uint64...</div></div></div></a><a class="pagination-related" href="/20221125/golang-20221125-golang%E7%AE%80%E4%BB%8B/" title="golang简介"><img class="cover" src="/img/yuanshen/avatar/72e25032ecca4e50849950cec4efd821.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang简介</div></div><div class="info-2"><div class="info-item-1">Go语言发展历史 阵容豪华的创使人团队 Ken Thompson  1966年：加入了贝尔实验室，在参与 Multics （多路信息计算）开发期间，创造出了B语言，并用一个月的时间用B语言开发了全新的操作系统UNICS，后来改名为我们所熟悉的UNIX 操作系统。 1971年：和丹尼斯·利奇（Dennis Ritchie）一起共同发明了C语言。 1973年：和丹尼斯·利奇（Dennis Ritchie）使用C语言重写了UNIX，并安装于PDP-11的机器之上。 1983年：美国计算机协会将图灵奖授予汤普森。 2000年：离开贝尔实验室，已退休的汤普森成为了一名飞行员。 2006年：加入Google工作。 2007年：64岁的高龄，与Rob Pike和Robert Griesemer主导了Go语言的开发。  Rob Pike  Go语言项目总负责人。 贝尔实验室Unix团队成员，参与的项目包括Plan 9，Inferno操作系统和Limbo编程语言。 UTF-8字符集规范唯二的发明人之一（另一位是Ken...</div></div></div></a><a class="pagination-related" href="/20221203/golang-20221203-golang%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="golang流程控制"><img class="cover" src="/img/yuanshen/avatar/d1a20cf431adcbef7f6fa3648c4b4cd4a2cc9f62.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-03</div><div class="info-item-2">golang流程控制</div></div><div class="info-2"><div class="info-item-1">if 123if 5 &gt; 9 &#123;    fmt.Println(&quot;5&gt;9&quot;)&#125;  如果逻辑表达式成立，就会执行{}里的内容。 逻辑表达式不需要加()。 &quot;{&quot;必须紧跟在逻辑表达式后面，不能另起一行。  123if c, d, e := 5, 9, 2; c &lt; d &amp;&amp; (c &gt; e || c &gt; 3) &#123; //初始化多个局部变量。复杂的逻辑表达式    fmt.Println(&quot;fit&quot;)&#125;  逻辑表达中可以含有变量或常量。 if句子中允许包含1个(仅1个)分号，在分号前初始化一些局部变量(即只在if块内可见)。  if-else的用法 12345678910color := &quot;black&quot;if color == &quot;red&quot; &#123; //if只能有一个    fmt.Println(&quot;stop&quot;)&#125; else if color ==...</div></div></div></a><a class="pagination-related" href="/20221211/golang-20221209-golang%E5%8C%85%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96/" title="golang包与工程化"><img class="cover" src="/img/yuanshen/avatar/b7fd5266d01609241b7224facde357f3e4cd34ed.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-11</div><div class="info-item-2">golang包与工程化</div></div><div class="info-2"><div class="info-item-1">用go mod管理工程   初始化项目: 1go mod init $module_name $module_name和目录名可以不一样。上述命令会生成go.mod文件，该文件内容形如： 12345678module go-coursego 1.17require (    github.com/ethereum/go-ethereum v1.10.8    github.com/gin-gonic/gin v1.7.4)   Go依次从当前项目、GOROOT、GOPATH下寻找依赖包。  从当前go文件所在的目录逐级向上查找go.mod文件（假设go.mod位于目录mode_path下），里面定义了module_name，则引入包的路径为&quot;module_name/包相对于mode_path的路径&quot;。 go标准库提供的包在GOROOT/src下。 第三方依赖包在GOPATH/pkg/mod下。    从go1.7开始，go get只负责下载第三方依赖包，并把它加到go.mod文件里，由go install负责安装二进制文件。  go get...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#GRPC%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="toc-number">1.</span> <span class="toc-text">GRPC技术栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-gRPC"><span class="toc-number">2.</span> <span class="toc-text">Hello gRPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#protobuf-grpc%E6%8F%92%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">protobuf grpc插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">生成代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gRPC%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">3.</span> <span class="toc-text">gRPC服务端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gRPC%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">4.</span> <span class="toc-text">gRPC客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gRPC%E6%B5%81"><span class="toc-number">5.</span> <span class="toc-text">gRPC流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90Streaming-RPC"><span class="toc-number">5.1.</span> <span class="toc-text">生成Streaming RPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-2"><span class="toc-number">5.2.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-2"><span class="toc-number">5.3.</span> <span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gRPC%E8%AE%A4%E8%AF%81"><span class="toc-number">6.</span> <span class="toc-text">gRPC认证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Request-Response%E8%AE%A4%E8%AF%81"><span class="toc-number">6.1.</span> <span class="toc-text">Request Response认证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">6.1.2.</span> <span class="toc-text">编写中间件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Server%E6%B7%BB%E5%8A%A0%E8%AE%A4%E8%AF%81"><span class="toc-number">6.1.3.</span> <span class="toc-text">Server添加认证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Client%E6%90%BA%E5%B8%A6%E8%AE%A4%E8%AF%81-%E5%9F%BA%E7%A1%80"><span class="toc-number">6.1.4.</span> <span class="toc-text">Client携带认证(基础)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Client%E6%90%BA%E5%B8%A6%E8%AE%A4%E8%AF%81-%E6%94%B9%E8%BF%9B"><span class="toc-number">6.1.5.</span> <span class="toc-text">Client携带认证(改进)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream-%E8%AE%A4%E8%AF%81"><span class="toc-number">6.2.</span> <span class="toc-text">Stream 认证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">6.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%B8%AD%E9%97%B4%E4%BB%B6-2"><span class="toc-number">6.2.2.</span> <span class="toc-text">编写中间件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Server%E6%B7%BB%E5%8A%A0%E8%AE%A4%E8%AF%81-2"><span class="toc-number">6.2.3.</span> <span class="toc-text">Server添加认证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%90%BA%E5%B8%A6%E8%AE%A4%E8%AF%81"><span class="toc-number">6.2.4.</span> <span class="toc-text">客户端携带认证</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By ren_mcc</div><div class="footer_custom_text"><a rel="noopener external nofollow noreferrer noopener" target="_blank" href="https://beian.miit.gov.cn/"> <img class="icp-icon entered loading" alt="ICP" src="/img/icp.png" data-ll-status><span>京ICP备2022001205号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: [''],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '990a12ec9f0481645c7d61434a2834ff'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><div class="aplayer no-destroy" data-id="7211977673" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="list" data-preload="none" data-autoplay="false" muted></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/docker/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 docker (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/docker-compose/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 docker-compose (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/containerd/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 containerd (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/kubernetes/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 kubernetes (27)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/python/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 python (37)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/golang/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 golang (38)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 redis (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/kafka/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 kafka (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://renm.cc/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><!-- hexo injector body_end end --></body></html>