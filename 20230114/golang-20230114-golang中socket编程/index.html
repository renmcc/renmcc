<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>golang中socket编程 | ren_mccの博客</title><meta name="author" content="ren_mcc"><meta name="copyright" content="ren_mcc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="网络通信过程   DMA：网卡和磁盘数据拷贝到内存流程比较固定，不涉及到运算操作，且非常耗时。在磁盘嵌入一个DMA芯片，完成上述拷贝工作，把CPU解脱出来，让CPU专注于运算。 mmap：用户空间和内核空间映射同一块内存空间，从而达到省略将数据从内核缓冲区拷贝到用户空间的操作，用户空间通过映射直接操作内核缓冲区的数据。  阻塞式网络I&#x2F;O  非阻塞式网络I&#x2F;O  多路复用网络I&#x2F;O    sock">
<meta property="og:type" content="article">
<meta property="og:title" content="golang中socket编程">
<meta property="og:url" content="https://renm.cc/20230114/golang-20230114-golang%E4%B8%ADsocket%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="ren_mccの博客">
<meta property="og:description" content="网络通信过程   DMA：网卡和磁盘数据拷贝到内存流程比较固定，不涉及到运算操作，且非常耗时。在磁盘嵌入一个DMA芯片，完成上述拷贝工作，把CPU解脱出来，让CPU专注于运算。 mmap：用户空间和内核空间映射同一块内存空间，从而达到省略将数据从内核缓冲区拷贝到用户空间的操作，用户空间通过映射直接操作内核缓冲区的数据。  阻塞式网络I&#x2F;O  非阻塞式网络I&#x2F;O  多路复用网络I&#x2F;O    sock">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://renm.cc/img/yuanshen/avatar/20210501094038_14f7d.webp">
<meta property="article:published_time" content="2023-01-13T17:31:51.000Z">
<meta property="article:modified_time" content="2023-06-28T13:47:21.763Z">
<meta property="article:author" content="ren_mcc">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://renm.cc/img/yuanshen/avatar/20210501094038_14f7d.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://renm.cc/20230114/golang-20230114-golang%E4%B8%ADsocket%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'golang中socket编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><script src="/js/jquery.min.js"></script><link rel="stylesheet" href="/js/function.min.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="/js/custom.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg" style="background-image: url(/img/backgroud7.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar2.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">148</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/yuanshen/avatar/20210501094038_14f7d.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ren_mccの博客</span></a><a class="nav-page-title" href="/"><span class="site-name">golang中socket编程</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">golang中socket编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-13T17:31:51.000Z" title="发表于 2023-01-14 01:31:51">2023-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-28T13:47:21.763Z" title="更新于 2023-06-28 21:47:21">2023-06-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/golang/">golang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2023-06-28 21:47:21&quot;}" hidden></div><h2 id="网络通信过程">网络通信过程</h2>
<p><img src="./%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" alt="avatar"></p>
<ul>
<li>DMA：网卡和磁盘数据拷贝到内存流程比较固定，不涉及到运算操作，且非常耗时。在磁盘嵌入一个DMA芯片，完成上述拷贝工作，把CPU解脱出来，让CPU专注于运算。</li>
<li>mmap：用户空间和内核空间映射同一块内存空间，从而达到省略将数据从内核缓冲区拷贝到用户空间的操作，用户空间通过映射直接操作内核缓冲区的数据。</li>
</ul>
<p>阻塞式网络I/O</p>
<p><img src="./%E9%98%BB%E5%A1%9E%E5%BC%8F%E7%BD%91%E7%BB%9CIO.png" alt="avatar"></p>
<p>非阻塞式网络I/O</p>
<p><img src="./%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BD%91%E7%BB%9CIO.png" alt="avatar"></p>
<p>多路复用网络I/O</p>
<p><img src="./%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%BD%91%E7%BB%9CIO.png" alt="avatar"></p>
<p>  socket把复杂的传输层协议封装成简单的接口，使应用层可以像读写文件一样进行网络数据的传输。</p>
<p><img src="./socket%E5%B1%82.png" alt="avatar"></p>
<p>socket通信过程</p>
<p><img src="./socket%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" alt="avatar"></p>
<h2 id="TCP-CS架构">TCP CS架构</h2>
<h3 id="网络通信模型">网络通信模型</h3>
<p>OSI参考模型</p>
<p><img src="./osi.png" alt="avatar"></p>
<p>TCP/IP模型</p>
<p><img src="./tcp_ip.png" alt="avatar"><br>
  传输层数据大小的上限为MSS(Maximum Segment Size, 最大分段大小)，网络接口层数据大小的上限为MTU(Maximum Transmit Unit, 最大传输单元)。</p>
<h3 id="TCP协议解读">TCP协议解读</h3>
<p>  MSS=MTU-ip首部-tcp首部，MTU视网络接口层的不同而不同。TCP在建立连接时通常需要协商双方的MSS值。应用层传输的数据大于MSS时需要分段。<br>
<img src="./tcp_segment.png" alt="avatar"><br>
TCP首部<br>
<img src="./tcp_head.png" alt="avatar"></p>
<ul>
<li>前20个字节是固定的，后面还4N个可选字节（TCP选项）。</li>
<li>数据偏移：TCP数据部分距TCP开头的偏移量（一个偏移量是4个字节， TCP选项占4N个字节），亦即TCP首部的长度。所以TCP首部的最大长度是15*4=60个字节，即TCP选项最多有40个字节。</li>
<li>端口在tcp层指定，ip在IP层指定。端口占2个字节，则最大端口号为2^16-1=65535。</li>
<li>由于应用层的数据被分段了，为了在接收端对数据按顺序重组，需要为每段数据编个“序号”。</li>
<li>TCP规定在连接建立后所有传送的报文段都必须把ACK设置为1。</li>
</ul>
<p>TCP建立连接<br>
<img src="./tcp_connect.png" alt="avatar"></p>
<ul>
<li>第一次握手：TCP首部SYN=1，初始化一个序号=J。SYN报文段不能携带数据。</li>
<li>第二次握手：TCP首部SYN=1，ACK=1，确认号=J+1，初始化一个序号=K。此报文同样不携带数据。</li>
<li>第三次握手：SYN=1，ACK=1，序号=J+1，确认号=K+1。此次一般会携带真正需要传输的数据。</li>
<li>确认号：即希望下次对方发过来的序号值。</li>
<li>SYN Flood 攻击始终不进行第三次握手，属于DDOS攻击的一种。</li>
</ul>
<p>TCP释放连接<br>
<img src="./tcp_disconect.png" alt="avatar"></p>
<ul>
<li>TCP的连接是全双工（可以同时发送和接收）的连接，因此在关闭连接的时候，必须关闭传送和接收两个方向上的连接。</li>
<li>第一次挥手：FIN=1，序号=M。</li>
<li>第二次挥手：ACK=1，序号=M+1。</li>
<li>第三次挥手：FIN=1，序号=N。</li>
<li>第四次挥手：ACK=1，序号=N+1。</li>
<li>从TIME_WAIT进入CLOSED需要经过2个MSL（Maxinum Segment Lifetime），RFC793建议MSL=2分钟。</li>
</ul>
<h3 id="Go-TCP编程">Go TCP编程</h3>
<ul>
<li>用三元给（ip地址，协议，端口号）唯一标示网络中的一个进程，如（172.122.121.111, tcp, 5656）。</li>
<li>IPv4的地址位数为32位，分为4段，每段最大取值为255。</li>
<li>IPv6的地址位数为128位，分为8段，各段用16进制表示，最大取值为ffff。</li>
<li>端口：0~1023被熟知的应用程序占用（普通应用程序不可以使用），49152~65535客户端程序运行时动态选择使用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ResolveTCPAddr</span><span class="params">(net, addr <span class="type">string</span>)</span></span> (*TCPAddr, os.Error)</span><br></pre></td></tr></table></figure>
<p>  net参数是“tcp4”、“tcp6”、“tcp”中的任意一个，分别表示TCP（IPv4-only），TCP（IPv6-only）或者TCP（IPv4,、IPv6的任意一个）。addr表示域名或者IP地址，例如&quot; <a target="_blank" rel="noopener" href="http://www.qq.com:80">www.qq.com:80</a>&quot; 或者&quot;127.0.0.1:22&quot;。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialTCP</span><span class="params">(network <span class="type">string</span>, laddr, raddr *TCPAddr)</span></span> (*TCPConn, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>  network参数是&quot;tcp4&quot;、“tcp6”、&quot;tcp&quot;中的任意一个。laddr表示本机地址，一般设置为nil。raddr表示远程的服务地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">net</span>.<span class="title">DialTimeout</span><span class="params">(network <span class="type">string</span>, address <span class="type">string</span>, timeout time.Duration)</span></span> (net.Conn, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>  创建连接时设置超时时间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*net.conn)</span></span> Write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>  通过conn发送数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(net.Conn)</span></span>.Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>  从conn里读取数据，如果没有数据可读，会阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ioutil</span>.<span class="title">ReadAll</span><span class="params">(r io.Reader)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>  从conn中读取所有内容，直到遇到error(比如连接关闭)或EOF。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenTCP</span><span class="params">(network <span class="type">string</span>, laddr *TCPAddr)</span></span> (*TCPListener, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>  监听端口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TCPListener)</span></span> Accept() (Conn, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>  阻塞，直到有客户端请求建立连接。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*net.conn)</span></span> Close() <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>  关闭连接。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span></span> SetReadDeadline(t time.Time) <span class="type">error</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span></span> SetWriteDeadline(t time.Time) <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>  设置从一个tcp连接上读取和写入的超时时间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TCPConn)</span></span> SetKeepAlive(keepalive <span class="type">bool</span>) os.Error</span><br></pre></td></tr></table></figure>
<p>  当一个tcp连接上没有数据时，操作系统会间隔性地发送心跳包，如果长时间没有收到心跳包会认为连接已经断开。</p>
<p>tcp_server.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	Request <span class="keyword">struct</span> &#123;</span><br><span class="line">		A <span class="type">int</span></span><br><span class="line">		B <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	Response <span class="keyword">struct</span> &#123;</span><br><span class="line">		Sum <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleRequest2</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="comment">//30秒后conn.Read会报出i/o timeout</span></span><br><span class="line">	conn.SetReadDeadline(time.Now().Add(<span class="number">30</span> * time.Second))</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="comment">//长连接，即连接建立后进行多轮的读写交互</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//初始化后byte数组每个元素都是0</span></span><br><span class="line">		requestBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">256</span>)</span><br><span class="line">		read_len, err := conn.Read(requestBytes)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;read from socket error: %s\n&quot;</span>, err.Error())</span><br><span class="line">			<span class="comment">//到达deadline后，退出for循环，关闭连接。client再用这个连接读写会发生错误</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//[]byte转string时，0后面的会自动被截掉</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;receive request %s\n&quot;</span>, <span class="type">string</span>(requestBytes[:read_len]))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> request Request</span><br><span class="line">		<span class="comment">//json反序列化时会把0都考虑在内，所以需要指定只读前read_len个字节</span></span><br><span class="line">		json.Unmarshal(requestBytes[:read_len], &amp;request)</span><br><span class="line">		response := Response&#123;Sum: request.A + request.B&#125;</span><br><span class="line"></span><br><span class="line">		responseBytes, _ := json.Marshal(response)</span><br><span class="line">		_, err = conn.Write(responseBytes)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;write response %s\n&quot;</span>, <span class="type">string</span>(responseBytes))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ip := <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">	port := <span class="number">5656</span></span><br><span class="line">	tcpAddr, err := net.ResolveTCPAddr(<span class="string">&quot;tcp4&quot;</span>, ip+<span class="string">&quot;:&quot;</span>+strconv.Itoa(port))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	listener, err := net.ListenTCP(<span class="string">&quot;tcp4&quot;</span>, tcpAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;waiting for client connection ......&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//操作系统会随机给客户端分配一个49152~65535上的端口号</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;establish connection to client %s\n&quot;</span>, conn.RemoteAddr().String())</span><br><span class="line">		<span class="keyword">go</span> handleRequest2(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>tcp_client.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	Request <span class="keyword">struct</span> &#123;</span><br><span class="line">		A <span class="type">int</span></span><br><span class="line">		B <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	Response <span class="keyword">struct</span> &#123;</span><br><span class="line">		Sum <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := net.DialTimeout(<span class="string">&quot;tcp4&quot;</span>, <span class="string">&quot;127.0.0.1:5656&quot;</span>, <span class="number">30</span>*time.Minute)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;establish connection to server %s\n&quot;</span>, conn.RemoteAddr().String())</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="comment">//长连接，即连接建立后进行多轮的读写交互</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		rand.Seed(time.Now().UnixNano())</span><br><span class="line">		request := Request&#123;A: rand.Intn(<span class="number">100</span>), B: rand.Intn(<span class="number">100</span>)&#125;</span><br><span class="line">		requestBytes, _ := json.Marshal(request)</span><br><span class="line">		_, err = conn.Write(requestBytes)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;write request %s\n&quot;</span>, <span class="type">string</span>(requestBytes))</span><br><span class="line">		<span class="comment">//初始化后byte数组每个元素都是0</span></span><br><span class="line">		responseBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">256</span>)</span><br><span class="line">		read_len, err := conn.Read(responseBytes)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> response Response</span><br><span class="line">		<span class="comment">//json反序列化时会把0都考虑在内，所以需要指定只读前read_len个字节</span></span><br><span class="line">		json.Unmarshal(responseBytes[:read_len], &amp;response)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;receive response: %d\n&quot;</span>, response.Sum)</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="UDP-CS架构">UDP CS架构</h2>
<h3 id="UDP协议解读">UDP协议解读</h3>
<p><img src="./udp_datagram.png" alt="avatar"></p>
<ul>
<li>UDP首部占8个字节，所以UDP报文长度最小是8B。</li>
<li>不需要建立连接，直接收发数据，效率很高</li>
<li>面向报文。对应用层交下来的报文，既不合并也不拆分，直接加上边界交给IP层。TCP是面向字节流，TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送；如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</li>
<li>从机制上不保证顺序（在IP层要对数据分段），可能会丢包（检验和如果出差错就会把这个报文丢弃掉）。在内网环境下分片乱序和数据丢包极少发生。</li>
<li>支持一对一、一对多、多对一和多对多的交互通信。</li>
</ul>
<h3 id="Go-UDP编程">Go UDP编程</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">net</span>.<span class="title">Dial</span><span class="params">(network <span class="type">string</span>, address <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>  netwok指定为udp，建立udp连接（伪连接）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">net</span>.<span class="title">DialTimeout</span><span class="params">(network <span class="type">string</span>, address <span class="type">string</span>, timeout time.Duration)</span></span> (net.Conn, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>  netwok指定为udp，建立连接时指定超时。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">net</span>.<span class="title">ResolveUDPAddr</span><span class="params">(network <span class="type">string</span>, address <span class="type">string</span>)</span></span> (*net.UDPAddr, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>  解析成udp地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">net</span>.<span class="title">ListenUDP</span><span class="params">(network <span class="type">string</span>, laddr *net.UDPAddr)</span></span> (*net.UDPConn, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>  直接调用Listen就返回一个udp连接。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*net.UDPConn)</span></span>.ReadFromUDP(b []<span class="type">byte</span>) (<span class="type">int</span>, *net.UDPAddr, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>  读数据，会返回remote的地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*net.UDPConn)</span></span>.WriteToUDP(b []<span class="type">byte</span>, addr *net.UDPAddr) (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>  写数据，需要指定remote的地址。<br>
udp_server.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	Request <span class="keyword">struct</span> &#123;</span><br><span class="line">		A <span class="type">int</span></span><br><span class="line">		B <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	Response <span class="keyword">struct</span> &#123;</span><br><span class="line">		Sum <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ip := <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">	port := <span class="number">5656</span></span><br><span class="line">	udpAddr, err := net.ResolveUDPAddr(<span class="string">&quot;udp&quot;</span>, ip+<span class="string">&quot;:&quot;</span>+strconv.Itoa(port))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//UDP不需要创建连接，所以不需要像TCP那样通过Accept()创建连接，这里的conn是个假连接</span></span><br><span class="line">	conn, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, udpAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 30秒后断开连接</span></span><br><span class="line">	<span class="comment">// conn.SetReadDeadline(time.Now().Add(30 * time.Second))</span></span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//初始化后byte数组每个元素都是0</span></span><br><span class="line">		requestBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">256</span>)</span><br><span class="line">		<span class="comment">//一个conn可以对应多个client，ReadFrom表示返回是哪个</span></span><br><span class="line">		read_len, remoteAddr, err := conn.ReadFromUDP(requestBytes)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;read from socket error: %s\n&quot;</span>, err.Error())</span><br><span class="line">			<span class="comment">//到达deadline后，退出for循环，关闭连接。client再用这个连接读写会发生错误</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//[]byte转string时，0后面的会自动被截掉</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;receive request %s from %s\n&quot;</span>, <span class="type">string</span>(requestBytes), remoteAddr.String())</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> request Request</span><br><span class="line">		<span class="comment">//json反序列化时会把0都考虑在内，所以需要指定只读前read_len个字节</span></span><br><span class="line">		json.Unmarshal(requestBytes[:read_len], &amp;request)</span><br><span class="line">		response := Response&#123;Sum: request.A + request.B&#125;</span><br><span class="line"></span><br><span class="line">		responseBytes, _ := json.Marshal(response)</span><br><span class="line">		<span class="comment">//由于UDP conn支持多对多通信，所以通信对方可能有多个EndPoint，通过WriteTo指定要写给哪个EndPoint</span></span><br><span class="line">		_, err = conn.WriteToUDP(responseBytes, remoteAddr)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;write response %s to %s\n&quot;</span>, <span class="type">string</span>(responseBytes), remoteAddr.String())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>udp_client.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	Request <span class="keyword">struct</span> &#123;</span><br><span class="line">		A <span class="type">int</span></span><br><span class="line">		B <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	Response <span class="keyword">struct</span> &#123;</span><br><span class="line">		Sum <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ip := <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">	port := <span class="number">5656</span></span><br><span class="line">	<span class="comment">//跟tcp_client的唯一区别就是这行代码</span></span><br><span class="line">	conn, err := net.DialTimeout(<span class="string">&quot;udp&quot;</span>, ip+<span class="string">&quot;:&quot;</span>+strconv.Itoa(port), <span class="number">30</span>*time.Minute) <span class="comment">//一个conn绑定一个本地端口</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="keyword">const</span> P = <span class="number">10</span></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(P)</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; P; i++ &#123;</span><br><span class="line">		request := Request&#123;A: rand.Intn(<span class="number">100</span>), B: rand.Intn(<span class="number">100</span>)&#125;</span><br><span class="line">		requestBytes, _ := json.Marshal(request)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//多协程，共用一个conn</span></span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			_, err = conn.Write(requestBytes)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Println(err.Error())</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;write request %s\n&quot;</span>, <span class="type">string</span>(requestBytes))</span><br><span class="line">			responseBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">256</span>)</span><br><span class="line">			read_len, err := conn.Read(responseBytes)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Println(err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">var</span> response Response</span><br><span class="line">			<span class="comment">//json反序列化时会把0都考虑在内，所以需要指定只读前read_len个字节</span></span><br><span class="line">			json.Unmarshal(responseBytes[:read_len], &amp;response)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;receive response: %d\n&quot;</span>, response.Sum)</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  由于UDP不需要建立连接，所以通过Dial()创建的是一个虚拟连接， Dial()总是会立即返回成功，即使对方还没有准备好。所以UDP可以先启client，再启server。由于是虚拟连接所以多个client可以共用一个conn，所以Server端往conn里写数据时需要指定写给哪个client，同理从conn里读数据会返回client的Address，即WriteToUDP (b []byte, addr *net.UDPAddr)和ReadFromUDP(b []byte) (int, *net.UDPAddr, error)。由于UDP是无连接和，对方关闭连接后，本方再在conn上调用Write和Read不会报错。<br>
  应用层的一条完整数据称为报文。TCP是面向字节流的，一次Read到的数据可能包含了多个报文，也可能只包含了半个报文，一条报文在什么地方结束需要通信双方事先约定好。UDP是面向报文的，一次Read只读一个报文，如果没有把一个报文读完，后面的内容会被丢弃掉，下次就读不到了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://renm.cc">ren_mcc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://renm.cc/20230114/golang-20230114-golang%E4%B8%ADsocket%E7%BC%96%E7%A8%8B/">https://renm.cc/20230114/golang-20230114-golang%E4%B8%ADsocket%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://renm.cc" target="_blank">ren_mccの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a></div><div class="post-share"><div class="social-share" data-image="/img/yuanshen/avatar/20210501094038_14f7d.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/20230120/golang-20230120-golang%E4%B8%ADwebsocket%E7%BC%96%E7%A8%8B/" title="golang中websocket编程"><img class="cover" src="/img/yuanshen/avatar/0df3d7ca7bcb0a462f0550cc7d87942d6a60af0a.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">golang中websocket编程</div></div><div class="info-2"><div class="info-item-1">WebSocket协议解读  websocket和http协议的关联：  都是应用层协议，都基于tcp传输协议。 跟http有良好的兼容性，ws和http的默认端口都是80，wss和https的默认端口都是443。 websocket在握手阶段采用http发送数据。  websocket和http协议的差异：  http是半双工，而websocket通过多路复用实现了全双工。 http只能由client主动发起数据请求，而websocket还可以由server主动向client推送数据。在需要及时刷新的场景中，http只能靠client高频地轮询，浪费严重。 http是短连接(也可以实现长连接, HTTP1.1...</div></div></div></a><a class="pagination-related" href="/20230112/golang-20230112-golang%E6%A0%87%E5%87%86%E5%BA%93http/" title="golang标准库http"><img class="cover" src="/img/yuanshen/avatar/TlrgVdsCp2SJUDmtMPjWGwc9aa6318b6680cd0a4f9b6e523f013df.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">golang标准库http</div></div><div class="info-2"><div class="info-item-1">http协议  http：超文本传输协议Hyper Text Transfer Protocol。 http属于应用层协议，它在传输层用的是tcp协议。 无状态，对事务处理没有记忆能力（对比TCP协议里的确认号）。如果要保存状态需要引用其他技术，如cookie。 无连接，每次连接只处理一个请求。早期带宽和计算资源有限，这么做是为了追求传输速度快，后来通过Connection: Keep-Alive实现长连接。http1.1废弃了Keep-Alive，默认支持长连接。   ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/20221125/golang-20221125-golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="golang基础语法"><img class="cover" src="/img/yuanshen/avatar/b7fd5266d01609241b7224facde357f3e4cd34ed.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang基础语法</div></div><div class="info-2"><div class="info-item-1">标识符与关键字   go变量、常量、自定义类型、包、函数的命名方式必须遵循以下规则：  首字符可以是任意Unicode字符或下划线。 首字符之外的部分可以是Unicode字符、下划线或数字。 名字的长度无限制。   理论上名字里可以有汉字，甚至可以全是汉字，但实际中不要这么做。  Go语言关键字 1break  default  func  interface  select  case  defer  go  map  struct  chan  else  goto  package  switch  const  if  range  type  continue  for  import  return  fallthrough  var 常量 1true  false  iota  nil    数据类型 1int  int8  int16  int32  int64  uint  uint8  uint16  uint32  uint64  uintptr  float32  float64  complex128  complex64  bool  byte ...</div></div></div></a><a class="pagination-related" href="/20221202/golang-20221202-golang%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/" title="golang格式化输出"><img class="cover" src="/img/yuanshen/avatar/97400f365b0b47cf8533d9d0b4ebe150!400x400.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-02</div><div class="info-item-2">golang格式化输出</div></div><div class="info-2"><div class="info-item-1">12345type WebSite struct &#123;	Name string&#125;var site = WebSite&#123;Name: &quot;ren123&quot;&#125; 普通占位符    占位符 说明 举例 输出     %v 相应值的默认格式 fmt.Printf(“site: %v\n”, site) site: {ren123}   %#v 响应值的Go语法表示 fmt.Printf(“site: %#v\n”, site) site: main.WebSite{Name:“ren123”}   %T 相应值的类型的Go语法表示 fmt.Printf(“site: %T\n”, site) site: main.WebSite   %% 字面上的百分号，并非值的占位符 fmt.Printf(“site: %%\n”, site) site: %    布尔占位符    占位符 说明 举例 输出     %t 单词true或false fmt.Printf(“b: %t\n”, b) b:...</div></div></div></a><a class="pagination-related" href="/20221125/golang-20221125-golang%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="golang数据类型"><img class="cover" src="/img/yuanshen/avatar/20210501094041_26fef.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang数据类型</div></div><div class="info-2"><div class="info-item-1">数据类型概览 基础数据类型    类型 长度(字节) 默认值 说明     bool 1 false    byte 1 0 uint8，取值范围[0,255]   rune 4 0 Unicode Code Point, int32   int, uint 4或8 0 32 或 64 位，取决于操作系统   int8, uint8 1 0 -128 ~ 127, 0 ~ 255   int16, uint16 2 0 -32768 ~ 32767, 0 ~ 65535   int32, uint32 4 0 -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名   int64, uint64 8 0    float32 4 0.0    float64 8 0.0    complex64 8     complex128 16     uintptr 4或8  以存储指针的 uint32 或 uint64...</div></div></div></a><a class="pagination-related" href="/20221125/golang-20221125-golang%E7%AE%80%E4%BB%8B/" title="golang简介"><img class="cover" src="/img/yuanshen/avatar/72e25032ecca4e50849950cec4efd821.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="info-item-2">golang简介</div></div><div class="info-2"><div class="info-item-1">Go语言发展历史 阵容豪华的创使人团队 Ken Thompson  1966年：加入了贝尔实验室，在参与 Multics （多路信息计算）开发期间，创造出了B语言，并用一个月的时间用B语言开发了全新的操作系统UNICS，后来改名为我们所熟悉的UNIX 操作系统。 1971年：和丹尼斯·利奇（Dennis Ritchie）一起共同发明了C语言。 1973年：和丹尼斯·利奇（Dennis Ritchie）使用C语言重写了UNIX，并安装于PDP-11的机器之上。 1983年：美国计算机协会将图灵奖授予汤普森。 2000年：离开贝尔实验室，已退休的汤普森成为了一名飞行员。 2006年：加入Google工作。 2007年：64岁的高龄，与Rob Pike和Robert Griesemer主导了Go语言的开发。  Rob Pike  Go语言项目总负责人。 贝尔实验室Unix团队成员，参与的项目包括Plan 9，Inferno操作系统和Limbo编程语言。 UTF-8字符集规范唯二的发明人之一（另一位是Ken...</div></div></div></a><a class="pagination-related" href="/20221203/golang-20221203-golang%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="golang流程控制"><img class="cover" src="/img/yuanshen/avatar/d1a20cf431adcbef7f6fa3648c4b4cd4a2cc9f62.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-03</div><div class="info-item-2">golang流程控制</div></div><div class="info-2"><div class="info-item-1">if 123if 5 &gt; 9 &#123;    fmt.Println(&quot;5&gt;9&quot;)&#125;  如果逻辑表达式成立，就会执行{}里的内容。 逻辑表达式不需要加()。 &quot;{&quot;必须紧跟在逻辑表达式后面，不能另起一行。  123if c, d, e := 5, 9, 2; c &lt; d &amp;&amp; (c &gt; e || c &gt; 3) &#123; //初始化多个局部变量。复杂的逻辑表达式    fmt.Println(&quot;fit&quot;)&#125;  逻辑表达中可以含有变量或常量。 if句子中允许包含1个(仅1个)分号，在分号前初始化一些局部变量(即只在if块内可见)。  if-else的用法 12345678910color := &quot;black&quot;if color == &quot;red&quot; &#123; //if只能有一个    fmt.Println(&quot;stop&quot;)&#125; else if color ==...</div></div></div></a><a class="pagination-related" href="/20221211/golang-20221209-golang%E5%8C%85%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96/" title="golang包与工程化"><img class="cover" src="/img/yuanshen/avatar/b7fd5266d01609241b7224facde357f3e4cd34ed.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-11</div><div class="info-item-2">golang包与工程化</div></div><div class="info-2"><div class="info-item-1">用go mod管理工程   初始化项目: 1go mod init $module_name $module_name和目录名可以不一样。上述命令会生成go.mod文件，该文件内容形如： 12345678module go-coursego 1.17require (    github.com/ethereum/go-ethereum v1.10.8    github.com/gin-gonic/gin v1.7.4)   Go依次从当前项目、GOROOT、GOPATH下寻找依赖包。  从当前go文件所在的目录逐级向上查找go.mod文件（假设go.mod位于目录mode_path下），里面定义了module_name，则引入包的路径为&quot;module_name/包相对于mode_path的路径&quot;。 go标准库提供的包在GOROOT/src下。 第三方依赖包在GOPATH/pkg/mod下。    从go1.7开始，go get只负责下载第三方依赖包，并把它加到go.mod文件里，由go install负责安装二进制文件。  go get...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">网络通信过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-CS%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">TCP CS架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">网络通信模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E8%A7%A3%E8%AF%BB"><span class="toc-number">2.2.</span> <span class="toc-text">TCP协议解读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-TCP%E7%BC%96%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">Go TCP编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP-CS%E6%9E%B6%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">UDP CS架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E5%8D%8F%E8%AE%AE%E8%A7%A3%E8%AF%BB"><span class="toc-number">3.1.</span> <span class="toc-text">UDP协议解读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-UDP%E7%BC%96%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">Go UDP编程</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By ren_mcc</div><div class="footer_custom_text"><a rel="noopener external nofollow noreferrer noopener" target="_blank" href="https://beian.miit.gov.cn/"> <img class="icp-icon entered loading" alt="ICP" src="/img/icp.png" data-ll-status><span>京ICP备2022001205号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: [''],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '58129e4901c8b9cd30bb5376e207c24f'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><div class="aplayer no-destroy" data-id="7211977673" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="list" data-preload="none" data-autoplay="false" muted></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/docker/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 docker (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/docker-compose/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 docker-compose (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/containerd/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 containerd (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/kubernetes/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 kubernetes (27)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/python/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 python (37)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/golang/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 golang (38)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 redis (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://renm.cc/categories/kafka/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 kafka (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://renm.cc/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><!-- hexo injector body_end end --></body></html>